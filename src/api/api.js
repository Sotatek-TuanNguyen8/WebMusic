"use strict";
/**
 * SGM-MUSIC-API
 * SGM-MUSIC-API
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadApi = exports.DownloadApiFp = exports.DownloadApiFetchParamCreator = exports.ContainerApiFactory = exports.ContainerApi = exports.ContainerApiFp = exports.ContainerApiFetchParamCreator = exports.ComposeTrackApiFactory = exports.ComposeTrackApi = exports.ComposeTrackApiFp = exports.ComposeTrackApiFetchParamCreator = exports.CartApiFactory = exports.CartApi = exports.CartApiFp = exports.CartApiFetchParamCreator = exports.BusinessTypeApiFactory = exports.BusinessTypeApi = exports.BusinessTypeApiFp = exports.BusinessTypeApiFetchParamCreator = exports.BillApiFactory = exports.BillApi = exports.BillApiFp = exports.BillApiFetchParamCreator = exports.ArtistApiFactory = exports.ArtistApi = exports.ArtistApiFp = exports.ArtistApiFetchParamCreator = exports.AccountTokenApiFactory = exports.AccountTokenApi = exports.AccountTokenApiFp = exports.AccountTokenApiFetchParamCreator = exports.AccountSubscriptionApiFactory = exports.AccountSubscriptionApi = exports.AccountSubscriptionApiFp = exports.AccountSubscriptionApiFetchParamCreator = exports.AccountProjectApiFactory = exports.AccountProjectApi = exports.AccountProjectApiFp = exports.AccountProjectApiFetchParamCreator = exports.AccountPlaylistApiFactory = exports.AccountPlaylistApi = exports.AccountPlaylistApiFp = exports.AccountPlaylistApiFetchParamCreator = exports.AccountApiFactory = exports.AccountApi = exports.AccountApiFp = exports.AccountApiFetchParamCreator = exports.BaseAPI = exports.BASE_PATH = exports.BAs3_T0k3n = void 0;
exports.TrackMoodApiFetchParamCreator = exports.TrackInPlaylistApiFactory = exports.TrackInPlaylistApi = exports.TrackInPlaylistApiFp = exports.TrackInPlaylistApiFetchParamCreator = exports.TrackInCartApiFactory = exports.TrackInCartApi = exports.TrackInCartApiFp = exports.TrackInCartApiFetchParamCreator = exports.TrackGenreApiFactory = exports.TrackGenreApi = exports.TrackGenreApiFp = exports.TrackGenreApiFetchParamCreator = exports.TrackApiFactory = exports.TrackApi = exports.TrackApiFp = exports.TrackApiFetchParamCreator = exports.TagApiFactory = exports.TagApi = exports.TagApiFp = exports.TagApiFetchParamCreator = exports.SubscriptionApiFactory = exports.SubscriptionApi = exports.SubscriptionApiFp = exports.SubscriptionApiFetchParamCreator = exports.ProjectApiFactory = exports.ProjectApi = exports.ProjectApiFp = exports.ProjectApiFetchParamCreator = exports.PriceApiFactory = exports.PriceApi = exports.PriceApiFp = exports.PriceApiFetchParamCreator = exports.PlaylistApiFactory = exports.PlaylistApi = exports.PlaylistApiFp = exports.PlaylistApiFetchParamCreator = exports.MoodApiFactory = exports.MoodApi = exports.MoodApiFp = exports.MoodApiFetchParamCreator = exports.GenreApiFactory = exports.GenreApi = exports.GenreApiFp = exports.GenreApiFetchParamCreator = exports.FeatureApiFactory = exports.FeatureApi = exports.FeatureApiFp = exports.FeatureApiFetchParamCreator = exports.DownloadApiFactory = void 0;
exports.UserApiFactory = exports.UserApi = exports.UserApiFp = exports.UserApiFetchParamCreator = exports.TrackMoodApiFactory = exports.TrackMoodApi = exports.TrackMoodApiFp = void 0;
const querystring = require("querystring");
const url = require("url");
const isomorphicFetch = require("isomorphic-fetch");
const assign = require("core-js/library/fn/object/assign");
const basePath = process.env.basePathApi;
exports.BAs3_T0k3n = process.env.bAs3_T0k3n;
exports.BASE_PATH = basePath.replace(/\/+$/, '');
class BaseAPI {
    basePath;
    fetch;
    constructor(fetch = isomorphicFetch, basePath = exports.BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}
exports.BaseAPI = BaseAPI;
/**
 * AccountApi - fetch parameter creator
 */
exports.AccountApiFetchParamCreator = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        // verify required parameter "oldPassword" is set
        if (params['oldPassword'] == null) {
            throw new Error('Missing required parameter oldPassword when calling accountChangePassword');
        }
        // verify required parameter "newPassword" is set
        if (params['newPassword'] == null) {
            throw new Error('Missing required parameter newPassword when calling accountChangePassword');
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            oldPassword: params['oldPassword'],
            newPassword: params['newPassword'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        // verify required parameter "uid" is set
        if (params['uid'] == null) {
            throw new Error('Missing required parameter uid when calling accountConfirm');
        }
        // verify required parameter "token" is set
        if (params['token'] == null) {
            throw new Error('Missing required parameter token when calling accountConfirm');
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            uid: params['uid'],
            token: params['token'],
            redirect: params['redirect'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountDeleteById');
        }
        const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountExistsGetAccountsidExists');
        }
        const baseUrl = `/Accounts/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountExistsHeadAccountsid');
        }
        const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountFindById');
        }
        const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        // verify required parameter "credentials" is set
        if (params['credentials'] == null) {
            throw new Error('Missing required parameter credentials when calling accountLogin');
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            include: params['include'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['credentials']) {
            fetchOptions.body = JSON.stringify(params['credentials'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts composes of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts downloads of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts feature of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountFeature');
        }
        const baseUrl = `/Accounts/{id}/feature/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts genre of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountGenre');
        }
        const baseUrl = `/Accounts/{id}/genre/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts makeSubscription of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts mood of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountMood');
        }
        const baseUrl = `/Accounts/{id}/mood/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts playlist of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts price of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountPrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountPrice');
        }
        const baseUrl = `/Accounts/{id}/price/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts project of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountProject');
        }
        const baseUrl = `/Accounts/{id}/project/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCountRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateCart');
        }
        const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in composes of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateComposes');
        }
        const baseUrl = `/Accounts/{id}/composes`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in downloads of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in feature of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateFeature');
        }
        const baseUrl = `/Accounts/{id}/feature`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in genre of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateGenre');
        }
        const baseUrl = `/Accounts/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in makeSubscription of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in mood of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateMood');
        }
        const baseUrl = `/Accounts/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in playlist of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreatePlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreatePlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in price of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreatePrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreatePrice');
        }
        const baseUrl = `/Accounts/{id}/price`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in project of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateProject');
        }
        const baseUrl = `/Accounts/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeCreateRoles');
        }
        const baseUrl = `/Accounts/{id}/roles`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all composes of this model.
     * @param id Account id
     */
    accountPrototypeDeleteComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteComposes');
        }
        const baseUrl = `/Accounts/{id}/composes`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all downloads of this model.
     * @param id Account id
     */
    accountPrototypeDeleteDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all feature of this model.
     * @param id Account id
     */
    accountPrototypeDeleteFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteFeature');
        }
        const baseUrl = `/Accounts/{id}/feature`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all genre of this model.
     * @param id Account id
     */
    accountPrototypeDeleteGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteGenre');
        }
        const baseUrl = `/Accounts/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all makeSubscription of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all mood of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteMood');
        }
        const baseUrl = `/Accounts/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all playlist of this model.
     * @param id Account id
     */
    accountPrototypeDeletePlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeletePlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all price of this model.
     * @param id Account id
     */
    accountPrototypeDeletePrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeletePrice');
        }
        const baseUrl = `/Accounts/{id}/price`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all project of this model.
     * @param id Account id
     */
    accountPrototypeDeleteProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteProject');
        }
        const baseUrl = `/Accounts/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDeleteRoles');
        }
        const baseUrl = `/Accounts/{id}/roles`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeDestroyByIdComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdComposes');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeDestroyByIdDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdDownloads');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     */
    accountPrototypeDestroyByIdFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdFeature');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdFeature');
        }
        const baseUrl = `/Accounts/{id}/feature/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     */
    accountPrototypeDestroyByIdGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdGenre');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdGenre');
        }
        const baseUrl = `/Accounts/{id}/genre/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     */
    accountPrototypeDestroyByIdMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdMakeSubscription');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     */
    accountPrototypeDestroyByIdMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdMood');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdMood');
        }
        const baseUrl = `/Accounts/{id}/mood/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeDestroyByIdPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     */
    accountPrototypeDestroyByIdPrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdPrice');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdPrice');
        }
        const baseUrl = `/Accounts/{id}/price/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeDestroyByIdProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdProject');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdProject');
        }
        const baseUrl = `/Accounts/{id}/project/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyByIdRoles');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeDestroyByIdRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes cart of this model.
     * @param id Account id
     */
    accountPrototypeDestroyCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeDestroyCart');
        }
        const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of composes relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeExistsComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeExistsComposes');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeExistsComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of downloads relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeExistsDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeExistsDownloads');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeExistsDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of playlist relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeExistsPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeExistsPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeExistsPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of project relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeExistsProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeExistsProject');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeExistsProject');
        }
        const baseUrl = `/Accounts/{id}/project/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeExistsRoles');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeExistsRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdAccessTokens');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeFindByIdComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdComposes');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeFindByIdDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdDownloads');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     */
    accountPrototypeFindByIdFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdFeature');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdFeature');
        }
        const baseUrl = `/Accounts/{id}/feature/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     */
    accountPrototypeFindByIdGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdGenre');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdGenre');
        }
        const baseUrl = `/Accounts/{id}/genre/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     */
    accountPrototypeFindByIdMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdMakeSubscription');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     */
    accountPrototypeFindByIdMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdMood');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdMood');
        }
        const baseUrl = `/Accounts/{id}/mood/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeFindByIdPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     */
    accountPrototypeFindByIdPrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdPrice');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdPrice');
        }
        const baseUrl = `/Accounts/{id}/price/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeFindByIdProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdProject');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdProject');
        }
        const baseUrl = `/Accounts/{id}/project/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeFindByIdRoles');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeFindByIdRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation businessType.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetBusinessType(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetBusinessType');
        }
        const baseUrl = `/Accounts/{id}/businessType`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches hasOne relation cart.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetCart');
        }
        const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries composes of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetComposes');
        }
        const baseUrl = `/Accounts/{id}/composes`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries downloads of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries feature of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetFeature');
        }
        const baseUrl = `/Accounts/{id}/feature`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries genre of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetGenre');
        }
        const baseUrl = `/Accounts/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries makeSubscription of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries mood of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetMood');
        }
        const baseUrl = `/Accounts/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries playlist of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries price of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetPrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetPrice');
        }
        const baseUrl = `/Accounts/{id}/price`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries project of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetProject');
        }
        const baseUrl = `/Accounts/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeGetRoles');
        }
        const baseUrl = `/Accounts/{id}/roles`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     * @param data
     */
    accountPrototypeLinkComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeLinkComposes');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeLinkComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     * @param data
     */
    accountPrototypeLinkDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeLinkDownloads');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeLinkDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     * @param data
     */
    accountPrototypeLinkPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeLinkPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeLinkPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     * @param data
     */
    accountPrototypeLinkProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeLinkProject');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeLinkProject');
        }
        const baseUrl = `/Accounts/{id}/project/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeLinkRoles');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeLinkRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypePatchAttributes');
        }
        const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the composes relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeUnlinkComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUnlinkComposes');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the downloads relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeUnlinkDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUnlinkDownloads');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the playlist relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeUnlinkPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUnlinkPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the project relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeUnlinkProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUnlinkProject');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkProject');
        }
        const baseUrl = `/Accounts/{id}/project/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUnlinkRoles');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUnlinkRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens');
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     * @param data
     */
    accountPrototypeUpdateByIdComposes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdComposes');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdComposes');
        }
        const baseUrl = `/Accounts/{id}/composes/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     * @param data
     */
    accountPrototypeUpdateByIdDownloads(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdDownloads');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdDownloads');
        }
        const baseUrl = `/Accounts/{id}/downloads/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     * @param data
     */
    accountPrototypeUpdateByIdFeature(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdFeature');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdFeature');
        }
        const baseUrl = `/Accounts/{id}/feature/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     * @param data
     */
    accountPrototypeUpdateByIdGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdGenre');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdGenre');
        }
        const baseUrl = `/Accounts/{id}/genre/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     * @param data
     */
    accountPrototypeUpdateByIdMakeSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdMakeSubscription');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdMakeSubscription');
        }
        const baseUrl = `/Accounts/{id}/makeSubscription/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     * @param data
     */
    accountPrototypeUpdateByIdMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdMood');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdMood');
        }
        const baseUrl = `/Accounts/{id}/mood/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     * @param data
     */
    accountPrototypeUpdateByIdPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdPlaylist');
        }
        const baseUrl = `/Accounts/{id}/playlist/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     * @param data
     */
    accountPrototypeUpdateByIdPrice(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdPrice');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdPrice');
        }
        const baseUrl = `/Accounts/{id}/price/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     * @param data
     */
    accountPrototypeUpdateByIdProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdProject');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdProject');
        }
        const baseUrl = `/Accounts/{id}/project/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateByIdRoles');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling accountPrototypeUpdateByIdRoles');
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update cart of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeUpdateCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeUpdateCart');
        }
        const baseUrl = `/Accounts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPrototypeVerify');
        }
        const baseUrl = `/Accounts/{id}/verify`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace');
        }
        const baseUrl = `/Accounts/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountReplaceByIdPutAccountsid');
        }
        const baseUrl = `/Accounts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        // verify required parameter "options" is set
        if (params['options'] == null) {
            throw new Error('Missing required parameter options when calling accountResetPassword');
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['options']) {
            fetchOptions.body = JSON.stringify(params['options'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        // verify required parameter "newPassword" is set
        if (params['newPassword'] == null) {
            throw new Error('Missing required parameter newPassword when calling accountSetPassword');
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            newPassword: params['newPassword'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountApi - functional programming interface
 */
exports.AccountApiFp = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogout(options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts composes of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts downloads of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts feature of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts genre of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts makeSubscription of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts mood of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts playlist of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts price of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountPrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountPrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts project of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateCart(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in composes of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in downloads of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in feature of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in genre of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in makeSubscription of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in mood of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in playlist of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreatePlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreatePlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in price of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreatePrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreatePrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in project of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all composes of this model.
     * @param id Account id
     */
    accountPrototypeDeleteComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all downloads of this model.
     * @param id Account id
     */
    accountPrototypeDeleteDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all feature of this model.
     * @param id Account id
     */
    accountPrototypeDeleteFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all genre of this model.
     * @param id Account id
     */
    accountPrototypeDeleteGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all makeSubscription of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all mood of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all playlist of this model.
     * @param id Account id
     */
    accountPrototypeDeletePlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeletePlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all price of this model.
     * @param id Account id
     */
    accountPrototypeDeletePrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeletePrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all project of this model.
     * @param id Account id
     */
    accountPrototypeDeleteProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeDestroyByIdComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeDestroyByIdDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     */
    accountPrototypeDestroyByIdFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     */
    accountPrototypeDestroyByIdGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     */
    accountPrototypeDestroyByIdMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     */
    accountPrototypeDestroyByIdMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeDestroyByIdPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     */
    accountPrototypeDestroyByIdPrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdPrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeDestroyByIdProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes cart of this model.
     * @param id Account id
     */
    accountPrototypeDestroyCart(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of composes relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeExistsComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of downloads relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeExistsDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of playlist relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeExistsPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of project relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeExistsProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeFindByIdComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeFindByIdDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     */
    accountPrototypeFindByIdFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     */
    accountPrototypeFindByIdGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     */
    accountPrototypeFindByIdMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     */
    accountPrototypeFindByIdMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeFindByIdPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     */
    accountPrototypeFindByIdPrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdPrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeFindByIdProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation businessType.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetBusinessType(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetBusinessType(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches hasOne relation cart.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetCart(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries composes of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries downloads of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries feature of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries genre of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries makeSubscription of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries mood of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries playlist of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries price of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetPrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetPrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries project of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     * @param data
     */
    accountPrototypeLinkComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     * @param data
     */
    accountPrototypeLinkDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     * @param data
     */
    accountPrototypeLinkPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     * @param data
     */
    accountPrototypeLinkProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the composes relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeUnlinkComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the downloads relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeUnlinkDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the playlist relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeUnlinkPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the project relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeUnlinkProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     * @param data
     */
    accountPrototypeUpdateByIdComposes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdComposes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     * @param data
     */
    accountPrototypeUpdateByIdDownloads(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     * @param data
     */
    accountPrototypeUpdateByIdFeature(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdFeature(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     * @param data
     */
    accountPrototypeUpdateByIdGenre(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     * @param data
     */
    accountPrototypeUpdateByIdMakeSubscription(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdMakeSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     * @param data
     */
    accountPrototypeUpdateByIdMood(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     * @param data
     */
    accountPrototypeUpdateByIdPlaylist(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     * @param data
     */
    accountPrototypeUpdateByIdPrice(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdPrice(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     * @param data
     */
    accountPrototypeUpdateByIdProject(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update cart of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeUpdateCart(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountApi - object-oriented interface
 */
class AccountApi extends BaseAPI {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        return exports.AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        return exports.AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        return exports.AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        return exports.AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        return exports.AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        return exports.AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        return exports.AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        return exports.AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        return exports.AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        return exports.AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        return exports.AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts composes of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeCountComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts downloads of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeCountDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts feature of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeCountFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts genre of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeCountGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts makeSubscription of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeCountMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts mood of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMood(params, options) {
        return exports.AccountApiFp.accountPrototypeCountMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts playlist of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeCountPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts price of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountPrice(params, options) {
        return exports.AccountApiFp.accountPrototypeCountPrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts project of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountProject(params, options) {
        return exports.AccountApiFp.accountPrototypeCountProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateCart(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in composes of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in downloads of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in feature of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in genre of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in makeSubscription of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in mood of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateMood(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in playlist of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreatePlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeCreatePlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in price of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreatePrice(params, options) {
        return exports.AccountApiFp.accountPrototypeCreatePrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in project of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateProject(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all composes of this model.
     * @param id Account id
     */
    accountPrototypeDeleteComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all downloads of this model.
     * @param id Account id
     */
    accountPrototypeDeleteDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all feature of this model.
     * @param id Account id
     */
    accountPrototypeDeleteFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all genre of this model.
     * @param id Account id
     */
    accountPrototypeDeleteGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all makeSubscription of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all mood of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMood(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all playlist of this model.
     * @param id Account id
     */
    accountPrototypeDeletePlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeDeletePlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all price of this model.
     * @param id Account id
     */
    accountPrototypeDeletePrice(params, options) {
        return exports.AccountApiFp.accountPrototypeDeletePrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all project of this model.
     * @param id Account id
     */
    accountPrototypeDeleteProject(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeDestroyByIdComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeDestroyByIdDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     */
    accountPrototypeDestroyByIdFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     */
    accountPrototypeDestroyByIdGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     */
    accountPrototypeDestroyByIdMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     */
    accountPrototypeDestroyByIdMood(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeDestroyByIdPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     */
    accountPrototypeDestroyByIdPrice(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdPrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeDestroyByIdProject(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes cart of this model.
     * @param id Account id
     */
    accountPrototypeDestroyCart(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of composes relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeExistsComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of downloads relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeExistsDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of playlist relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeExistsPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of project relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeExistsProject(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeFindByIdComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeFindByIdDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     */
    accountPrototypeFindByIdFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     */
    accountPrototypeFindByIdGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     */
    accountPrototypeFindByIdMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     */
    accountPrototypeFindByIdMood(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeFindByIdPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     */
    accountPrototypeFindByIdPrice(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdPrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeFindByIdProject(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation businessType.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetBusinessType(params, options) {
        return exports.AccountApiFp.accountPrototypeGetBusinessType(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches hasOne relation cart.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetCart(params, options) {
        return exports.AccountApiFp.accountPrototypeGetCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries composes of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeGetComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries downloads of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeGetDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries feature of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeGetFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries genre of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeGetGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries makeSubscription of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeGetMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries mood of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetMood(params, options) {
        return exports.AccountApiFp.accountPrototypeGetMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries playlist of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeGetPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries price of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetPrice(params, options) {
        return exports.AccountApiFp.accountPrototypeGetPrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries project of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetProject(params, options) {
        return exports.AccountApiFp.accountPrototypeGetProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     * @param data
     */
    accountPrototypeLinkComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     * @param data
     */
    accountPrototypeLinkDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     * @param data
     */
    accountPrototypeLinkPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     * @param data
     */
    accountPrototypeLinkProject(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the composes relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for composes
     */
    accountPrototypeUnlinkComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the downloads relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for downloads
     */
    accountPrototypeUnlinkDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the playlist relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for playlist
     */
    accountPrototypeUnlinkPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the project relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for project
     */
    accountPrototypeUnlinkProject(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for composes.
     * @param id Account id
     * @param fk Foreign key for composes
     * @param data
     */
    accountPrototypeUpdateByIdComposes(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdComposes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for downloads.
     * @param id Account id
     * @param fk Foreign key for downloads
     * @param data
     */
    accountPrototypeUpdateByIdDownloads(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for feature.
     * @param id Account id
     * @param fk Foreign key for feature
     * @param data
     */
    accountPrototypeUpdateByIdFeature(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdFeature(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for genre.
     * @param id Account id
     * @param fk Foreign key for genre
     * @param data
     */
    accountPrototypeUpdateByIdGenre(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for makeSubscription.
     * @param id Account id
     * @param fk Foreign key for makeSubscription
     * @param data
     */
    accountPrototypeUpdateByIdMakeSubscription(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdMakeSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for mood.
     * @param id Account id
     * @param fk Foreign key for mood
     * @param data
     */
    accountPrototypeUpdateByIdMood(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for playlist.
     * @param id Account id
     * @param fk Foreign key for playlist
     * @param data
     */
    accountPrototypeUpdateByIdPlaylist(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for price.
     * @param id Account id
     * @param fk Foreign key for price
     * @param data
     */
    accountPrototypeUpdateByIdPrice(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdPrice(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for project.
     * @param id Account id
     * @param fk Foreign key for project
     * @param data
     */
    accountPrototypeUpdateByIdProject(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update cart of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeUpdateCart(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        return exports.AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        return exports.AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        return exports.AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        return exports.AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        return exports.AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountApi = AccountApi;
/**
 * AccountApi - factory interface
 */
const AccountApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Change a user's password.
         * @param oldPassword
         * @param newPassword
         */
        accountChangePassword(params, options) {
            return exports.AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm a user registration with identity verification token.
         * @param uid
         * @param token
         * @param redirect
         */
        accountConfirm(params, options) {
            return exports.AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params, options) {
            return exports.AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params, options) {
            return exports.AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamGetAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamPostAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params, options) {
            return exports.AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params, options) {
            return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params, options) {
            return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params, options) {
            return exports.AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params, options) {
            return exports.AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params, options) {
            return exports.AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Login a user with username/email and password.
         * @param credentials
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params, options) {
            return exports.AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logout a user with access token.
         */
        accountLogout(options) {
            return exports.AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params, options) {
            return exports.AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts composes of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeCountComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts downloads of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeCountDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts feature of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeCountFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts genre of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeCountGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts makeSubscription of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeCountMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts mood of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountMood(params, options) {
            return exports.AccountApiFp.accountPrototypeCountMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts playlist of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeCountPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts price of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountPrice(params, options) {
            return exports.AccountApiFp.accountPrototypeCountPrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts project of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountProject(params, options) {
            return exports.AccountApiFp.accountPrototypeCountProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in cart of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateCart(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in composes of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in downloads of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in feature of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in genre of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in makeSubscription of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in mood of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateMood(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in playlist of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreatePlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeCreatePlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in price of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreatePrice(params, options) {
            return exports.AccountApiFp.accountPrototypeCreatePrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in project of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateProject(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all composes of this model.
         * @param id Account id
         */
        accountPrototypeDeleteComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all downloads of this model.
         * @param id Account id
         */
        accountPrototypeDeleteDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all feature of this model.
         * @param id Account id
         */
        accountPrototypeDeleteFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all genre of this model.
         * @param id Account id
         */
        accountPrototypeDeleteGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all makeSubscription of this model.
         * @param id Account id
         */
        accountPrototypeDeleteMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all mood of this model.
         * @param id Account id
         */
        accountPrototypeDeleteMood(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all playlist of this model.
         * @param id Account id
         */
        accountPrototypeDeletePlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeDeletePlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all price of this model.
         * @param id Account id
         */
        accountPrototypeDeletePrice(params, options) {
            return exports.AccountApiFp.accountPrototypeDeletePrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all project of this model.
         * @param id Account id
         */
        accountPrototypeDeleteProject(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for composes.
         * @param id Account id
         * @param fk Foreign key for composes
         */
        accountPrototypeDestroyByIdComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for downloads.
         * @param id Account id
         * @param fk Foreign key for downloads
         */
        accountPrototypeDestroyByIdDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for feature.
         * @param id Account id
         * @param fk Foreign key for feature
         */
        accountPrototypeDestroyByIdFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for genre.
         * @param id Account id
         * @param fk Foreign key for genre
         */
        accountPrototypeDestroyByIdGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for makeSubscription.
         * @param id Account id
         * @param fk Foreign key for makeSubscription
         */
        accountPrototypeDestroyByIdMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for mood.
         * @param id Account id
         * @param fk Foreign key for mood
         */
        accountPrototypeDestroyByIdMood(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for playlist.
         * @param id Account id
         * @param fk Foreign key for playlist
         */
        accountPrototypeDestroyByIdPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for price.
         * @param id Account id
         * @param fk Foreign key for price
         */
        accountPrototypeDestroyByIdPrice(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdPrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for project.
         * @param id Account id
         * @param fk Foreign key for project
         */
        accountPrototypeDestroyByIdProject(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes cart of this model.
         * @param id Account id
         */
        accountPrototypeDestroyCart(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of composes relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for composes
         */
        accountPrototypeExistsComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of downloads relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for downloads
         */
        accountPrototypeExistsDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of playlist relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for playlist
         */
        accountPrototypeExistsPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of project relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for project
         */
        accountPrototypeExistsProject(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for composes.
         * @param id Account id
         * @param fk Foreign key for composes
         */
        accountPrototypeFindByIdComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for downloads.
         * @param id Account id
         * @param fk Foreign key for downloads
         */
        accountPrototypeFindByIdDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for feature.
         * @param id Account id
         * @param fk Foreign key for feature
         */
        accountPrototypeFindByIdFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for genre.
         * @param id Account id
         * @param fk Foreign key for genre
         */
        accountPrototypeFindByIdGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for makeSubscription.
         * @param id Account id
         * @param fk Foreign key for makeSubscription
         */
        accountPrototypeFindByIdMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for mood.
         * @param id Account id
         * @param fk Foreign key for mood
         */
        accountPrototypeFindByIdMood(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for playlist.
         * @param id Account id
         * @param fk Foreign key for playlist
         */
        accountPrototypeFindByIdPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for price.
         * @param id Account id
         * @param fk Foreign key for price
         */
        accountPrototypeFindByIdPrice(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdPrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for project.
         * @param id Account id
         * @param fk Foreign key for project
         */
        accountPrototypeFindByIdProject(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation businessType.
         * @param id Account id
         * @param refresh
         */
        accountPrototypeGetBusinessType(params, options) {
            return exports.AccountApiFp.accountPrototypeGetBusinessType(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches hasOne relation cart.
         * @param id Account id
         * @param refresh
         */
        accountPrototypeGetCart(params, options) {
            return exports.AccountApiFp.accountPrototypeGetCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries composes of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeGetComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries downloads of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeGetDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries feature of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeGetFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries genre of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeGetGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries makeSubscription of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeGetMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries mood of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetMood(params, options) {
            return exports.AccountApiFp.accountPrototypeGetMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries playlist of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeGetPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries price of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetPrice(params, options) {
            return exports.AccountApiFp.accountPrototypeGetPrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries project of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetProject(params, options) {
            return exports.AccountApiFp.accountPrototypeGetProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for composes.
         * @param id Account id
         * @param fk Foreign key for composes
         * @param data
         */
        accountPrototypeLinkComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for downloads.
         * @param id Account id
         * @param fk Foreign key for downloads
         * @param data
         */
        accountPrototypeLinkDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for playlist.
         * @param id Account id
         * @param fk Foreign key for playlist
         * @param data
         */
        accountPrototypeLinkPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for project.
         * @param id Account id
         * @param fk Foreign key for project
         * @param data
         */
        accountPrototypeLinkProject(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeLinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params, options) {
            return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the composes relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for composes
         */
        accountPrototypeUnlinkComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the downloads relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for downloads
         */
        accountPrototypeUnlinkDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the playlist relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for playlist
         */
        accountPrototypeUnlinkPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the project relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for project
         */
        accountPrototypeUnlinkProject(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data
         */
        accountPrototypeUpdateByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for composes.
         * @param id Account id
         * @param fk Foreign key for composes
         * @param data
         */
        accountPrototypeUpdateByIdComposes(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdComposes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for downloads.
         * @param id Account id
         * @param fk Foreign key for downloads
         * @param data
         */
        accountPrototypeUpdateByIdDownloads(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for feature.
         * @param id Account id
         * @param fk Foreign key for feature
         * @param data
         */
        accountPrototypeUpdateByIdFeature(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdFeature(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for genre.
         * @param id Account id
         * @param fk Foreign key for genre
         * @param data
         */
        accountPrototypeUpdateByIdGenre(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for makeSubscription.
         * @param id Account id
         * @param fk Foreign key for makeSubscription
         * @param data
         */
        accountPrototypeUpdateByIdMakeSubscription(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdMakeSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for mood.
         * @param id Account id
         * @param fk Foreign key for mood
         * @param data
         */
        accountPrototypeUpdateByIdMood(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for playlist.
         * @param id Account id
         * @param fk Foreign key for playlist
         * @param data
         */
        accountPrototypeUpdateByIdPlaylist(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for price.
         * @param id Account id
         * @param fk Foreign key for price
         * @param data
         */
        accountPrototypeUpdateByIdPrice(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdPrice(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for project.
         * @param id Account id
         * @param fk Foreign key for project
         * @param data
         */
        accountPrototypeUpdateByIdProject(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeUpdateByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update cart of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeUpdateCart(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params, options) {
            return exports.AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password for a user with email.
         * @param options
         */
        accountResetPassword(params, options) {
            return exports.AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset user's password via a password-reset token.
         * @param newPassword
         */
        accountSetPassword(params, options) {
            return exports.AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params, options) {
            return exports.AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params, options) {
            return exports.AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountPlaylistApi - fetch parameter creator
 */
exports.AccountPlaylistApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountPlaylistCount(params, options) {
        const baseUrl = `/AccountPlaylists/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountPlaylistCreate(params, options) {
        const baseUrl = `/AccountPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options) {
        const baseUrl = `/AccountPlaylists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options) {
        const baseUrl = `/AccountPlaylists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountPlaylistDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistDeleteById');
        }
        const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountPlaylistExistsGetAccountPlaylistsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistExistsGetAccountPlaylistsidExists');
        }
        const baseUrl = `/AccountPlaylists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountPlaylistExistsHeadAccountPlaylistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistExistsHeadAccountPlaylistsid');
        }
        const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountPlaylistFind(params, options) {
        const baseUrl = `/AccountPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountPlaylistFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistFindById');
        }
        const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountPlaylistFindOne(params, options) {
        const baseUrl = `/AccountPlaylists/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistPatchOrCreate(params, options) {
        const baseUrl = `/AccountPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountPlaylist id
     * @param refresh
     */
    accountPlaylistPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistPrototypeGetAccount');
        }
        const baseUrl = `/AccountPlaylists/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation playlist.
     * @param id AccountPlaylist id
     * @param refresh
     */
    accountPlaylistPrototypeGetPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistPrototypeGetPlaylist');
        }
        const baseUrl = `/AccountPlaylists/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountPlaylist id
     * @param data An object of model property name/value pairs
     */
    accountPlaylistPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistPrototypePatchAttributes');
        }
        const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistReplaceByIdPostAccountPlaylistsidReplace');
        }
        const baseUrl = `/AccountPlaylists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountPlaylistReplaceByIdPutAccountPlaylistsid');
        }
        const baseUrl = `/AccountPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options) {
        const baseUrl = `/AccountPlaylists/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options) {
        const baseUrl = `/AccountPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountPlaylistUpdateAll(params, options) {
        const baseUrl = `/AccountPlaylists/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountPlaylistUpsertWithWhere(params, options) {
        const baseUrl = `/AccountPlaylists/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountPlaylistApi - functional programming interface
 */
exports.AccountPlaylistApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountPlaylistCount(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountPlaylistCreate(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountPlaylistDeleteById(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountPlaylistExistsGetAccountPlaylistsidExists(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistExistsGetAccountPlaylistsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountPlaylistExistsHeadAccountPlaylistsid(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistExistsHeadAccountPlaylistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountPlaylistFind(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountPlaylistFindById(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountPlaylistFindOne(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountPlaylist id
     * @param refresh
     */
    accountPlaylistPrototypeGetAccount(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation playlist.
     * @param id AccountPlaylist id
     * @param refresh
     */
    accountPlaylistPrototypeGetPlaylist(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistPrototypeGetPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountPlaylist id
     * @param data An object of model property name/value pairs
     */
    accountPlaylistPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountPlaylistUpdateAll(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountPlaylistUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountPlaylistApiFetchParamCreator.accountPlaylistUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountPlaylistApi - object-oriented interface
 */
class AccountPlaylistApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountPlaylistCount(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountPlaylistCreate(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountPlaylistDeleteById(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountPlaylistExistsGetAccountPlaylistsidExists(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistExistsGetAccountPlaylistsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountPlaylistExistsHeadAccountPlaylistsid(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistExistsHeadAccountPlaylistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountPlaylistFind(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountPlaylistFindById(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountPlaylistFindOne(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistPatchOrCreate(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountPlaylist id
     * @param refresh
     */
    accountPlaylistPrototypeGetAccount(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation playlist.
     * @param id AccountPlaylist id
     * @param refresh
     */
    accountPlaylistPrototypeGetPlaylist(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistPrototypeGetPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountPlaylist id
     * @param data An object of model property name/value pairs
     */
    accountPlaylistPrototypePatchAttributes(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountPlaylistUpdateAll(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountPlaylistUpsertWithWhere(params, options) {
        return exports.AccountPlaylistApiFp.accountPlaylistUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountPlaylistApi = AccountPlaylistApi;
/**
 * AccountPlaylistApi - factory interface
 */
const AccountPlaylistApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountPlaylistCount(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountPlaylistCreate(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistCreateChangeStreamGetAccountPlaylistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistCreateChangeStreamPostAccountPlaylistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountPlaylistDeleteById(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountPlaylistExistsGetAccountPlaylistsidExists(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistExistsGetAccountPlaylistsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountPlaylistExistsHeadAccountPlaylistsid(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistExistsHeadAccountPlaylistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountPlaylistFind(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountPlaylistFindById(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountPlaylistFindOne(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPlaylistPatchOrCreate(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id AccountPlaylist id
         * @param refresh
         */
        accountPlaylistPrototypeGetAccount(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation playlist.
         * @param id AccountPlaylist id
         * @param refresh
         */
        accountPlaylistPrototypeGetPlaylist(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistPrototypeGetPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountPlaylist id
         * @param data An object of model property name/value pairs
         */
        accountPlaylistPrototypePatchAttributes(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistReplaceByIdPostAccountPlaylistsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistReplaceByIdPutAccountPlaylistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePostAccountPlaylistsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistReplaceOrCreatePutAccountPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountPlaylistUpdateAll(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountPlaylistUpsertWithWhere(params, options) {
            return exports.AccountPlaylistApiFp.accountPlaylistUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountPlaylistApiFactory = AccountPlaylistApiFactory;
/**
 * AccountProjectApi - fetch parameter creator
 */
exports.AccountProjectApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountProjectCount(params, options) {
        const baseUrl = `/AccountProjects/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountProjectCreate(params, options) {
        const baseUrl = `/AccountProjects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options) {
        const baseUrl = `/AccountProjects/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options) {
        const baseUrl = `/AccountProjects/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountProjectDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectDeleteById');
        }
        const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountProjectExistsGetAccountProjectsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectExistsGetAccountProjectsidExists');
        }
        const baseUrl = `/AccountProjects/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountProjectExistsHeadAccountProjectsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectExistsHeadAccountProjectsid');
        }
        const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountProjectFind(params, options) {
        const baseUrl = `/AccountProjects`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountProjectFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectFindById');
        }
        const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountProjectFindOne(params, options) {
        const baseUrl = `/AccountProjects/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectPatchOrCreate(params, options) {
        const baseUrl = `/AccountProjects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountProject id
     * @param refresh
     */
    accountProjectPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectPrototypeGetAccount');
        }
        const baseUrl = `/AccountProjects/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation project.
     * @param id AccountProject id
     * @param refresh
     */
    accountProjectPrototypeGetProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectPrototypeGetProject');
        }
        const baseUrl = `/AccountProjects/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountProject id
     * @param data An object of model property name/value pairs
     */
    accountProjectPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectPrototypePatchAttributes');
        }
        const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountProjectReplaceByIdPostAccountProjectsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectReplaceByIdPostAccountProjectsidReplace');
        }
        const baseUrl = `/AccountProjects/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountProjectReplaceByIdPutAccountProjectsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountProjectReplaceByIdPutAccountProjectsid');
        }
        const baseUrl = `/AccountProjects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options) {
        const baseUrl = `/AccountProjects/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectReplaceOrCreatePutAccountProjects(params, options) {
        const baseUrl = `/AccountProjects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountProjectUpdateAll(params, options) {
        const baseUrl = `/AccountProjects/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountProjectUpsertWithWhere(params, options) {
        const baseUrl = `/AccountProjects/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountProjectApi - functional programming interface
 */
exports.AccountProjectApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountProjectCount(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountProjectCreate(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountProjectDeleteById(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountProjectExistsGetAccountProjectsidExists(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectExistsGetAccountProjectsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountProjectExistsHeadAccountProjectsid(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectExistsHeadAccountProjectsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountProjectFind(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountProjectFindById(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountProjectFindOne(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountProject id
     * @param refresh
     */
    accountProjectPrototypeGetAccount(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation project.
     * @param id AccountProject id
     * @param refresh
     */
    accountProjectPrototypeGetProject(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectPrototypeGetProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountProject id
     * @param data An object of model property name/value pairs
     */
    accountProjectPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountProjectReplaceByIdPostAccountProjectsidReplace(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectReplaceByIdPostAccountProjectsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountProjectReplaceByIdPutAccountProjectsid(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectReplaceByIdPutAccountProjectsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectReplaceOrCreatePutAccountProjects(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectReplaceOrCreatePutAccountProjects(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountProjectUpdateAll(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountProjectUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountProjectApiFetchParamCreator.accountProjectUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountProjectApi - object-oriented interface
 */
class AccountProjectApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountProjectCount(params, options) {
        return exports.AccountProjectApiFp.accountProjectCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountProjectCreate(params, options) {
        return exports.AccountProjectApiFp.accountProjectCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options) {
        return exports.AccountProjectApiFp.accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options) {
        return exports.AccountProjectApiFp.accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountProjectDeleteById(params, options) {
        return exports.AccountProjectApiFp.accountProjectDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountProjectExistsGetAccountProjectsidExists(params, options) {
        return exports.AccountProjectApiFp.accountProjectExistsGetAccountProjectsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountProjectExistsHeadAccountProjectsid(params, options) {
        return exports.AccountProjectApiFp.accountProjectExistsHeadAccountProjectsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountProjectFind(params, options) {
        return exports.AccountProjectApiFp.accountProjectFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountProjectFindById(params, options) {
        return exports.AccountProjectApiFp.accountProjectFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountProjectFindOne(params, options) {
        return exports.AccountProjectApiFp.accountProjectFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectPatchOrCreate(params, options) {
        return exports.AccountProjectApiFp.accountProjectPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountProject id
     * @param refresh
     */
    accountProjectPrototypeGetAccount(params, options) {
        return exports.AccountProjectApiFp.accountProjectPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation project.
     * @param id AccountProject id
     * @param refresh
     */
    accountProjectPrototypeGetProject(params, options) {
        return exports.AccountProjectApiFp.accountProjectPrototypeGetProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountProject id
     * @param data An object of model property name/value pairs
     */
    accountProjectPrototypePatchAttributes(params, options) {
        return exports.AccountProjectApiFp.accountProjectPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountProjectReplaceByIdPostAccountProjectsidReplace(params, options) {
        return exports.AccountProjectApiFp.accountProjectReplaceByIdPostAccountProjectsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountProjectReplaceByIdPutAccountProjectsid(params, options) {
        return exports.AccountProjectApiFp.accountProjectReplaceByIdPutAccountProjectsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options) {
        return exports.AccountProjectApiFp.accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountProjectReplaceOrCreatePutAccountProjects(params, options) {
        return exports.AccountProjectApiFp.accountProjectReplaceOrCreatePutAccountProjects(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountProjectUpdateAll(params, options) {
        return exports.AccountProjectApiFp.accountProjectUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountProjectUpsertWithWhere(params, options) {
        return exports.AccountProjectApiFp.accountProjectUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountProjectApi = AccountProjectApi;
/**
 * AccountProjectApi - factory interface
 */
const AccountProjectApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountProjectCount(params, options) {
            return exports.AccountProjectApiFp.accountProjectCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountProjectCreate(params, options) {
            return exports.AccountProjectApiFp.accountProjectCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options) {
            return exports.AccountProjectApiFp.accountProjectCreateChangeStreamGetAccountProjectsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options) {
            return exports.AccountProjectApiFp.accountProjectCreateChangeStreamPostAccountProjectsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountProjectDeleteById(params, options) {
            return exports.AccountProjectApiFp.accountProjectDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountProjectExistsGetAccountProjectsidExists(params, options) {
            return exports.AccountProjectApiFp.accountProjectExistsGetAccountProjectsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountProjectExistsHeadAccountProjectsid(params, options) {
            return exports.AccountProjectApiFp.accountProjectExistsHeadAccountProjectsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountProjectFind(params, options) {
            return exports.AccountProjectApiFp.accountProjectFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountProjectFindById(params, options) {
            return exports.AccountProjectApiFp.accountProjectFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountProjectFindOne(params, options) {
            return exports.AccountProjectApiFp.accountProjectFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountProjectPatchOrCreate(params, options) {
            return exports.AccountProjectApiFp.accountProjectPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id AccountProject id
         * @param refresh
         */
        accountProjectPrototypeGetAccount(params, options) {
            return exports.AccountProjectApiFp.accountProjectPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation project.
         * @param id AccountProject id
         * @param refresh
         */
        accountProjectPrototypeGetProject(params, options) {
            return exports.AccountProjectApiFp.accountProjectPrototypeGetProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountProject id
         * @param data An object of model property name/value pairs
         */
        accountProjectPrototypePatchAttributes(params, options) {
            return exports.AccountProjectApiFp.accountProjectPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountProjectReplaceByIdPostAccountProjectsidReplace(params, options) {
            return exports.AccountProjectApiFp.accountProjectReplaceByIdPostAccountProjectsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountProjectReplaceByIdPutAccountProjectsid(params, options) {
            return exports.AccountProjectApiFp.accountProjectReplaceByIdPutAccountProjectsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options) {
            return exports.AccountProjectApiFp.accountProjectReplaceOrCreatePostAccountProjectsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountProjectReplaceOrCreatePutAccountProjects(params, options) {
            return exports.AccountProjectApiFp.accountProjectReplaceOrCreatePutAccountProjects(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountProjectUpdateAll(params, options) {
            return exports.AccountProjectApiFp.accountProjectUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountProjectUpsertWithWhere(params, options) {
            return exports.AccountProjectApiFp.accountProjectUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountProjectApiFactory = AccountProjectApiFactory;
/**
 * AccountSubscriptionApi - fetch parameter creator
 */
exports.AccountSubscriptionApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountSubscriptionCount(params, options) {
        const baseUrl = `/AccountSubscriptions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountSubscriptionCreate(params, options) {
        const baseUrl = `/AccountSubscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options) {
        const baseUrl = `/AccountSubscriptions/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options) {
        const baseUrl = `/AccountSubscriptions/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountSubscriptionDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionDeleteById');
        }
        const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionExistsGetAccountSubscriptionsidExists');
        }
        const baseUrl = `/AccountSubscriptions/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountSubscriptionExistsHeadAccountSubscriptionsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionExistsHeadAccountSubscriptionsid');
        }
        const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountSubscriptionFind(params, options) {
        const baseUrl = `/AccountSubscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountSubscriptionFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionFindById');
        }
        const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountSubscriptionFindOne(params, options) {
        const baseUrl = `/AccountSubscriptions/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionPatchOrCreate(params, options) {
        const baseUrl = `/AccountSubscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountSubscription id
     * @param refresh
     */
    accountSubscriptionPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionPrototypeGetAccount');
        }
        const baseUrl = `/AccountSubscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation subscription.
     * @param id AccountSubscription id
     * @param refresh
     */
    accountSubscriptionPrototypeGetSubscription(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionPrototypeGetSubscription');
        }
        const baseUrl = `/AccountSubscriptions/{id}/subscription`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountSubscription id
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionPrototypePatchAttributes');
        }
        const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace');
        }
        const baseUrl = `/AccountSubscriptions/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountSubscriptionReplaceByIdPutAccountSubscriptionsid');
        }
        const baseUrl = `/AccountSubscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options) {
        const baseUrl = `/AccountSubscriptions/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options) {
        const baseUrl = `/AccountSubscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionUpdateAll(params, options) {
        const baseUrl = `/AccountSubscriptions/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionUpsertWithWhere(params, options) {
        const baseUrl = `/AccountSubscriptions/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountSubscriptionApi - functional programming interface
 */
exports.AccountSubscriptionApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountSubscriptionCount(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountSubscriptionCreate(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountSubscriptionDeleteById(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountSubscriptionExistsHeadAccountSubscriptionsid(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionExistsHeadAccountSubscriptionsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountSubscriptionFind(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountSubscriptionFindById(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountSubscriptionFindOne(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountSubscription id
     * @param refresh
     */
    accountSubscriptionPrototypeGetAccount(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation subscription.
     * @param id AccountSubscription id
     * @param refresh
     */
    accountSubscriptionPrototypeGetSubscription(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionPrototypeGetSubscription(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountSubscription id
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionUpdateAll(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountSubscriptionApiFetchParamCreator.accountSubscriptionUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountSubscriptionApi - object-oriented interface
 */
class AccountSubscriptionApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountSubscriptionCount(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountSubscriptionCreate(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountSubscriptionDeleteById(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountSubscriptionExistsHeadAccountSubscriptionsid(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionExistsHeadAccountSubscriptionsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountSubscriptionFind(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountSubscriptionFindById(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountSubscriptionFindOne(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionPatchOrCreate(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id AccountSubscription id
     * @param refresh
     */
    accountSubscriptionPrototypeGetAccount(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation subscription.
     * @param id AccountSubscription id
     * @param refresh
     */
    accountSubscriptionPrototypeGetSubscription(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionPrototypeGetSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountSubscription id
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionPrototypePatchAttributes(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionUpdateAll(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountSubscriptionUpsertWithWhere(params, options) {
        return exports.AccountSubscriptionApiFp.accountSubscriptionUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountSubscriptionApi = AccountSubscriptionApi;
/**
 * AccountSubscriptionApi - factory interface
 */
const AccountSubscriptionApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountSubscriptionCount(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountSubscriptionCreate(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamGetAccountSubscriptionsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionCreateChangeStreamPostAccountSubscriptionsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountSubscriptionDeleteById(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionExistsGetAccountSubscriptionsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountSubscriptionExistsHeadAccountSubscriptionsid(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionExistsHeadAccountSubscriptionsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountSubscriptionFind(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountSubscriptionFindById(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountSubscriptionFindOne(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountSubscriptionPatchOrCreate(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id AccountSubscription id
         * @param refresh
         */
        accountSubscriptionPrototypeGetAccount(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation subscription.
         * @param id AccountSubscription id
         * @param refresh
         */
        accountSubscriptionPrototypeGetSubscription(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionPrototypeGetSubscription(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountSubscription id
         * @param data An object of model property name/value pairs
         */
        accountSubscriptionPrototypePatchAttributes(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPostAccountSubscriptionsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceByIdPutAccountSubscriptionsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePostAccountSubscriptionsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionReplaceOrCreatePutAccountSubscriptions(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountSubscriptionUpdateAll(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountSubscriptionUpsertWithWhere(params, options) {
            return exports.AccountSubscriptionApiFp.accountSubscriptionUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountSubscriptionApiFactory = AccountSubscriptionApiFactory;
/**
 * AccountTokenApi - fetch parameter creator
 */
exports.AccountTokenApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenDeleteById');
        }
        const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists');
        }
        const baseUrl = `/AccountTokens/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenExistsHeadAccountTokensid');
        }
        const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenFindById');
        }
        const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenPrototypeGetUser');
        }
        const baseUrl = `/AccountTokens/{id}/user`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenPrototypePatchAttributes');
        }
        const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace');
        }
        const baseUrl = `/AccountTokens/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid');
        }
        const baseUrl = `/AccountTokens/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountTokenApi - functional programming interface
 */
exports.AccountTokenApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountTokenApi - object-oriented interface
 */
class AccountTokenApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        return exports.AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        return exports.AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountTokenApi = AccountTokenApi;
/**
 * AccountTokenApi - factory interface
 */
const AccountTokenApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params, options) {
            return exports.AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params, options) {
            return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params, options) {
            return exports.AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh
         */
        accountTokenPrototypeGetUser(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountTokenApiFactory = AccountTokenApiFactory;
/**
 * ArtistApi - fetch parameter creator
 */
exports.ArtistApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    artistCount(params, options) {
        const baseUrl = `/Artists/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    artistCreate(params, options) {
        const baseUrl = `/Artists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    artistCreateChangeStreamGetArtistsChangeStream(params, options) {
        const baseUrl = `/Artists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    artistCreateChangeStreamPostArtistsChangeStream(params, options) {
        const baseUrl = `/Artists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    artistDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistDeleteById');
        }
        const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    artistExistsGetArtistsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistExistsGetArtistsidExists');
        }
        const baseUrl = `/Artists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    artistExistsHeadArtistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistExistsHeadArtistsid');
        }
        const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    artistFind(params, options) {
        const baseUrl = `/Artists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    artistFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistFindById');
        }
        const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    artistFindOne(params, options) {
        const baseUrl = `/Artists/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistPatchOrCreate(params, options) {
        const baseUrl = `/Artists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Artist id
     * @param data An object of model property name/value pairs
     */
    artistPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistPrototypePatchAttributes');
        }
        const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    artistReplaceByIdPostArtistsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistReplaceByIdPostArtistsidReplace');
        }
        const baseUrl = `/Artists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    artistReplaceByIdPutArtistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling artistReplaceByIdPutArtistsid');
        }
        const baseUrl = `/Artists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options) {
        const baseUrl = `/Artists/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistReplaceOrCreatePutArtists(params, options) {
        const baseUrl = `/Artists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    artistUpdateAll(params, options) {
        const baseUrl = `/Artists/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    artistUpsertWithWhere(params, options) {
        const baseUrl = `/Artists/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ArtistApi - functional programming interface
 */
exports.ArtistApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    artistCount(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    artistCreate(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    artistCreateChangeStreamGetArtistsChangeStream(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistCreateChangeStreamGetArtistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    artistCreateChangeStreamPostArtistsChangeStream(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistCreateChangeStreamPostArtistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    artistDeleteById(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    artistExistsGetArtistsidExists(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistExistsGetArtistsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    artistExistsHeadArtistsid(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistExistsHeadArtistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    artistFind(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    artistFindById(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    artistFindOne(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistPatchOrCreate(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Artist id
     * @param data An object of model property name/value pairs
     */
    artistPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    artistReplaceByIdPostArtistsidReplace(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistReplaceByIdPostArtistsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    artistReplaceByIdPutArtistsid(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistReplaceByIdPutArtistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistReplaceOrCreatePutArtists(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistReplaceOrCreatePutArtists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    artistUpdateAll(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    artistUpsertWithWhere(params, options) {
        const fetchArgs = exports.ArtistApiFetchParamCreator.artistUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ArtistApi - object-oriented interface
 */
class ArtistApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    artistCount(params, options) {
        return exports.ArtistApiFp.artistCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    artistCreate(params, options) {
        return exports.ArtistApiFp.artistCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    artistCreateChangeStreamGetArtistsChangeStream(params, options) {
        return exports.ArtistApiFp.artistCreateChangeStreamGetArtistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    artistCreateChangeStreamPostArtistsChangeStream(params, options) {
        return exports.ArtistApiFp.artistCreateChangeStreamPostArtistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    artistDeleteById(params, options) {
        return exports.ArtistApiFp.artistDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    artistExistsGetArtistsidExists(params, options) {
        return exports.ArtistApiFp.artistExistsGetArtistsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    artistExistsHeadArtistsid(params, options) {
        return exports.ArtistApiFp.artistExistsHeadArtistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    artistFind(params, options) {
        return exports.ArtistApiFp.artistFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    artistFindById(params, options) {
        return exports.ArtistApiFp.artistFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    artistFindOne(params, options) {
        return exports.ArtistApiFp.artistFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistPatchOrCreate(params, options) {
        return exports.ArtistApiFp.artistPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Artist id
     * @param data An object of model property name/value pairs
     */
    artistPrototypePatchAttributes(params, options) {
        return exports.ArtistApiFp.artistPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    artistReplaceByIdPostArtistsidReplace(params, options) {
        return exports.ArtistApiFp.artistReplaceByIdPostArtistsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    artistReplaceByIdPutArtistsid(params, options) {
        return exports.ArtistApiFp.artistReplaceByIdPutArtistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options) {
        return exports.ArtistApiFp.artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    artistReplaceOrCreatePutArtists(params, options) {
        return exports.ArtistApiFp.artistReplaceOrCreatePutArtists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    artistUpdateAll(params, options) {
        return exports.ArtistApiFp.artistUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    artistUpsertWithWhere(params, options) {
        return exports.ArtistApiFp.artistUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ArtistApi = ArtistApi;
/**
 * ArtistApi - factory interface
 */
const ArtistApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        artistCount(params, options) {
            return exports.ArtistApiFp.artistCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        artistCreate(params, options) {
            return exports.ArtistApiFp.artistCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        artistCreateChangeStreamGetArtistsChangeStream(params, options) {
            return exports.ArtistApiFp.artistCreateChangeStreamGetArtistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        artistCreateChangeStreamPostArtistsChangeStream(params, options) {
            return exports.ArtistApiFp.artistCreateChangeStreamPostArtistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        artistDeleteById(params, options) {
            return exports.ArtistApiFp.artistDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        artistExistsGetArtistsidExists(params, options) {
            return exports.ArtistApiFp.artistExistsGetArtistsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        artistExistsHeadArtistsid(params, options) {
            return exports.ArtistApiFp.artistExistsHeadArtistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        artistFind(params, options) {
            return exports.ArtistApiFp.artistFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        artistFindById(params, options) {
            return exports.ArtistApiFp.artistFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        artistFindOne(params, options) {
            return exports.ArtistApiFp.artistFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        artistPatchOrCreate(params, options) {
            return exports.ArtistApiFp.artistPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Artist id
         * @param data An object of model property name/value pairs
         */
        artistPrototypePatchAttributes(params, options) {
            return exports.ArtistApiFp.artistPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        artistReplaceByIdPostArtistsidReplace(params, options) {
            return exports.ArtistApiFp.artistReplaceByIdPostArtistsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        artistReplaceByIdPutArtistsid(params, options) {
            return exports.ArtistApiFp.artistReplaceByIdPutArtistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options) {
            return exports.ArtistApiFp.artistReplaceOrCreatePostArtistsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        artistReplaceOrCreatePutArtists(params, options) {
            return exports.ArtistApiFp.artistReplaceOrCreatePutArtists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        artistUpdateAll(params, options) {
            return exports.ArtistApiFp.artistUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        artistUpsertWithWhere(params, options) {
            return exports.ArtistApiFp.artistUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ArtistApiFactory = ArtistApiFactory;
/**
 * BillApi - fetch parameter creator
 */
exports.BillApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    billCount(params, options) {
        const baseUrl = `/Bills/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    billCreate(params, options) {
        const baseUrl = `/Bills`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    billCreateChangeStreamGetBillsChangeStream(params, options) {
        const baseUrl = `/Bills/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    billCreateChangeStreamPostBillsChangeStream(params, options) {
        const baseUrl = `/Bills/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    billDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billDeleteById');
        }
        const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    billExistsGetBillsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billExistsGetBillsidExists');
        }
        const baseUrl = `/Bills/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    billExistsHeadBillsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billExistsHeadBillsid');
        }
        const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    billFind(params, options) {
        const baseUrl = `/Bills`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    billFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billFindById');
        }
        const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    billFindOne(params, options) {
        const baseUrl = `/Bills/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billPatchOrCreate(params, options) {
        const baseUrl = `/Bills`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Bill id
     * @param data An object of model property name/value pairs
     */
    billPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billPrototypePatchAttributes');
        }
        const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    billReplaceByIdPostBillsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billReplaceByIdPostBillsidReplace');
        }
        const baseUrl = `/Bills/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    billReplaceByIdPutBillsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling billReplaceByIdPutBillsid');
        }
        const baseUrl = `/Bills/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billReplaceOrCreatePostBillsReplaceOrCreate(params, options) {
        const baseUrl = `/Bills/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billReplaceOrCreatePutBills(params, options) {
        const baseUrl = `/Bills`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    billUpdateAll(params, options) {
        const baseUrl = `/Bills/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    billUpsertWithWhere(params, options) {
        const baseUrl = `/Bills/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * BillApi - functional programming interface
 */
exports.BillApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    billCount(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    billCreate(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    billCreateChangeStreamGetBillsChangeStream(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billCreateChangeStreamGetBillsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    billCreateChangeStreamPostBillsChangeStream(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billCreateChangeStreamPostBillsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    billDeleteById(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    billExistsGetBillsidExists(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billExistsGetBillsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    billExistsHeadBillsid(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billExistsHeadBillsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    billFind(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    billFindById(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    billFindOne(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billPatchOrCreate(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Bill id
     * @param data An object of model property name/value pairs
     */
    billPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    billReplaceByIdPostBillsidReplace(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billReplaceByIdPostBillsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    billReplaceByIdPutBillsid(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billReplaceByIdPutBillsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billReplaceOrCreatePostBillsReplaceOrCreate(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billReplaceOrCreatePostBillsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billReplaceOrCreatePutBills(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billReplaceOrCreatePutBills(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    billUpdateAll(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    billUpsertWithWhere(params, options) {
        const fetchArgs = exports.BillApiFetchParamCreator.billUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * BillApi - object-oriented interface
 */
class BillApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    billCount(params, options) {
        return exports.BillApiFp.billCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    billCreate(params, options) {
        return exports.BillApiFp.billCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    billCreateChangeStreamGetBillsChangeStream(params, options) {
        return exports.BillApiFp.billCreateChangeStreamGetBillsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    billCreateChangeStreamPostBillsChangeStream(params, options) {
        return exports.BillApiFp.billCreateChangeStreamPostBillsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    billDeleteById(params, options) {
        return exports.BillApiFp.billDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    billExistsGetBillsidExists(params, options) {
        return exports.BillApiFp.billExistsGetBillsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    billExistsHeadBillsid(params, options) {
        return exports.BillApiFp.billExistsHeadBillsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    billFind(params, options) {
        return exports.BillApiFp.billFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    billFindById(params, options) {
        return exports.BillApiFp.billFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    billFindOne(params, options) {
        return exports.BillApiFp.billFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billPatchOrCreate(params, options) {
        return exports.BillApiFp.billPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Bill id
     * @param data An object of model property name/value pairs
     */
    billPrototypePatchAttributes(params, options) {
        return exports.BillApiFp.billPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    billReplaceByIdPostBillsidReplace(params, options) {
        return exports.BillApiFp.billReplaceByIdPostBillsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    billReplaceByIdPutBillsid(params, options) {
        return exports.BillApiFp.billReplaceByIdPutBillsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billReplaceOrCreatePostBillsReplaceOrCreate(params, options) {
        return exports.BillApiFp.billReplaceOrCreatePostBillsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    billReplaceOrCreatePutBills(params, options) {
        return exports.BillApiFp.billReplaceOrCreatePutBills(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    billUpdateAll(params, options) {
        return exports.BillApiFp.billUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    billUpsertWithWhere(params, options) {
        return exports.BillApiFp.billUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.BillApi = BillApi;
/**
 * BillApi - factory interface
 */
const BillApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        billCount(params, options) {
            return exports.BillApiFp.billCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        billCreate(params, options) {
            return exports.BillApiFp.billCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        billCreateChangeStreamGetBillsChangeStream(params, options) {
            return exports.BillApiFp.billCreateChangeStreamGetBillsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        billCreateChangeStreamPostBillsChangeStream(params, options) {
            return exports.BillApiFp.billCreateChangeStreamPostBillsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        billDeleteById(params, options) {
            return exports.BillApiFp.billDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        billExistsGetBillsidExists(params, options) {
            return exports.BillApiFp.billExistsGetBillsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        billExistsHeadBillsid(params, options) {
            return exports.BillApiFp.billExistsHeadBillsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        billFind(params, options) {
            return exports.BillApiFp.billFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        billFindById(params, options) {
            return exports.BillApiFp.billFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        billFindOne(params, options) {
            return exports.BillApiFp.billFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        billPatchOrCreate(params, options) {
            return exports.BillApiFp.billPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Bill id
         * @param data An object of model property name/value pairs
         */
        billPrototypePatchAttributes(params, options) {
            return exports.BillApiFp.billPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        billReplaceByIdPostBillsidReplace(params, options) {
            return exports.BillApiFp.billReplaceByIdPostBillsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        billReplaceByIdPutBillsid(params, options) {
            return exports.BillApiFp.billReplaceByIdPutBillsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        billReplaceOrCreatePostBillsReplaceOrCreate(params, options) {
            return exports.BillApiFp.billReplaceOrCreatePostBillsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        billReplaceOrCreatePutBills(params, options) {
            return exports.BillApiFp.billReplaceOrCreatePutBills(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        billUpdateAll(params, options) {
            return exports.BillApiFp.billUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        billUpsertWithWhere(params, options) {
            return exports.BillApiFp.billUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.BillApiFactory = BillApiFactory;
/**
 * BusinessTypeApi - fetch parameter creator
 */
exports.BusinessTypeApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    businessTypeCount(params, options) {
        const baseUrl = `/BusinessTypes/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    businessTypeCreate(params, options) {
        const baseUrl = `/BusinessTypes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options) {
        const baseUrl = `/BusinessTypes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options) {
        const baseUrl = `/BusinessTypes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    businessTypeDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypeDeleteById');
        }
        const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    businessTypeExistsGetBusinessTypesidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypeExistsGetBusinessTypesidExists');
        }
        const baseUrl = `/BusinessTypes/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    businessTypeExistsHeadBusinessTypesid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypeExistsHeadBusinessTypesid');
        }
        const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    businessTypeFind(params, options) {
        const baseUrl = `/BusinessTypes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    businessTypeFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypeFindById');
        }
        const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    businessTypeFindOne(params, options) {
        const baseUrl = `/BusinessTypes/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypePatchOrCreate(params, options) {
        const baseUrl = `/BusinessTypes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts account of BusinessType.
     * @param id BusinessType id
     * @param where Criteria to match model instances
     */
    businessTypePrototypeCountAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeCountAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in account of this model.
     * @param id BusinessType id
     * @param data
     */
    businessTypePrototypeCreateAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeCreateAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all account of this model.
     * @param id BusinessType id
     */
    businessTypePrototypeDeleteAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeDeleteAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     */
    businessTypePrototypeDestroyByIdAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeDestroyByIdAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling businessTypePrototypeDestroyByIdAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     */
    businessTypePrototypeFindByIdAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeFindByIdAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling businessTypePrototypeFindByIdAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries account of BusinessType.
     * @param id BusinessType id
     * @param filter
     */
    businessTypePrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeGetAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id BusinessType id
     * @param data An object of model property name/value pairs
     */
    businessTypePrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypePatchAttributes');
        }
        const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     * @param data
     */
    businessTypePrototypeUpdateByIdAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypePrototypeUpdateByIdAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling businessTypePrototypeUpdateByIdAccount');
        }
        const baseUrl = `/BusinessTypes/{id}/account/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    businessTypeReplaceByIdPostBusinessTypesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypeReplaceByIdPostBusinessTypesidReplace');
        }
        const baseUrl = `/BusinessTypes/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    businessTypeReplaceByIdPutBusinessTypesid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling businessTypeReplaceByIdPutBusinessTypesid');
        }
        const baseUrl = `/BusinessTypes/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options) {
        const baseUrl = `/BusinessTypes/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypeReplaceOrCreatePutBusinessTypes(params, options) {
        const baseUrl = `/BusinessTypes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    businessTypeUpdateAll(params, options) {
        const baseUrl = `/BusinessTypes/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    businessTypeUpsertWithWhere(params, options) {
        const baseUrl = `/BusinessTypes/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * BusinessTypeApi - functional programming interface
 */
exports.BusinessTypeApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    businessTypeCount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    businessTypeCreate(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    businessTypeDeleteById(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    businessTypeExistsGetBusinessTypesidExists(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeExistsGetBusinessTypesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    businessTypeExistsHeadBusinessTypesid(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeExistsHeadBusinessTypesid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    businessTypeFind(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    businessTypeFindById(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    businessTypeFindOne(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypePatchOrCreate(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts account of BusinessType.
     * @param id BusinessType id
     * @param where Criteria to match model instances
     */
    businessTypePrototypeCountAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeCountAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in account of this model.
     * @param id BusinessType id
     * @param data
     */
    businessTypePrototypeCreateAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeCreateAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all account of this model.
     * @param id BusinessType id
     */
    businessTypePrototypeDeleteAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeDeleteAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     */
    businessTypePrototypeDestroyByIdAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeDestroyByIdAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     */
    businessTypePrototypeFindByIdAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeFindByIdAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries account of BusinessType.
     * @param id BusinessType id
     * @param filter
     */
    businessTypePrototypeGetAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id BusinessType id
     * @param data An object of model property name/value pairs
     */
    businessTypePrototypePatchAttributes(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     * @param data
     */
    businessTypePrototypeUpdateByIdAccount(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypePrototypeUpdateByIdAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    businessTypeReplaceByIdPostBusinessTypesidReplace(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeReplaceByIdPostBusinessTypesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    businessTypeReplaceByIdPutBusinessTypesid(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeReplaceByIdPutBusinessTypesid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypeReplaceOrCreatePutBusinessTypes(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeReplaceOrCreatePutBusinessTypes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    businessTypeUpdateAll(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    businessTypeUpsertWithWhere(params, options) {
        const fetchArgs = exports.BusinessTypeApiFetchParamCreator.businessTypeUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * BusinessTypeApi - object-oriented interface
 */
class BusinessTypeApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    businessTypeCount(params, options) {
        return exports.BusinessTypeApiFp.businessTypeCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    businessTypeCreate(params, options) {
        return exports.BusinessTypeApiFp.businessTypeCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options) {
        return exports.BusinessTypeApiFp.businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options) {
        return exports.BusinessTypeApiFp.businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    businessTypeDeleteById(params, options) {
        return exports.BusinessTypeApiFp.businessTypeDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    businessTypeExistsGetBusinessTypesidExists(params, options) {
        return exports.BusinessTypeApiFp.businessTypeExistsGetBusinessTypesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    businessTypeExistsHeadBusinessTypesid(params, options) {
        return exports.BusinessTypeApiFp.businessTypeExistsHeadBusinessTypesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    businessTypeFind(params, options) {
        return exports.BusinessTypeApiFp.businessTypeFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    businessTypeFindById(params, options) {
        return exports.BusinessTypeApiFp.businessTypeFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    businessTypeFindOne(params, options) {
        return exports.BusinessTypeApiFp.businessTypeFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypePatchOrCreate(params, options) {
        return exports.BusinessTypeApiFp.businessTypePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts account of BusinessType.
     * @param id BusinessType id
     * @param where Criteria to match model instances
     */
    businessTypePrototypeCountAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeCountAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in account of this model.
     * @param id BusinessType id
     * @param data
     */
    businessTypePrototypeCreateAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeCreateAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all account of this model.
     * @param id BusinessType id
     */
    businessTypePrototypeDeleteAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeDeleteAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     */
    businessTypePrototypeDestroyByIdAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeDestroyByIdAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     */
    businessTypePrototypeFindByIdAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeFindByIdAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries account of BusinessType.
     * @param id BusinessType id
     * @param filter
     */
    businessTypePrototypeGetAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id BusinessType id
     * @param data An object of model property name/value pairs
     */
    businessTypePrototypePatchAttributes(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for account.
     * @param id BusinessType id
     * @param fk Foreign key for account
     * @param data
     */
    businessTypePrototypeUpdateByIdAccount(params, options) {
        return exports.BusinessTypeApiFp.businessTypePrototypeUpdateByIdAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    businessTypeReplaceByIdPostBusinessTypesidReplace(params, options) {
        return exports.BusinessTypeApiFp.businessTypeReplaceByIdPostBusinessTypesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    businessTypeReplaceByIdPutBusinessTypesid(params, options) {
        return exports.BusinessTypeApiFp.businessTypeReplaceByIdPutBusinessTypesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options) {
        return exports.BusinessTypeApiFp.businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    businessTypeReplaceOrCreatePutBusinessTypes(params, options) {
        return exports.BusinessTypeApiFp.businessTypeReplaceOrCreatePutBusinessTypes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    businessTypeUpdateAll(params, options) {
        return exports.BusinessTypeApiFp.businessTypeUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    businessTypeUpsertWithWhere(params, options) {
        return exports.BusinessTypeApiFp.businessTypeUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.BusinessTypeApi = BusinessTypeApi;
/**
 * BusinessTypeApi - factory interface
 */
const BusinessTypeApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        businessTypeCount(params, options) {
            return exports.BusinessTypeApiFp.businessTypeCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        businessTypeCreate(params, options) {
            return exports.BusinessTypeApiFp.businessTypeCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options) {
            return exports.BusinessTypeApiFp.businessTypeCreateChangeStreamGetBusinessTypesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options) {
            return exports.BusinessTypeApiFp.businessTypeCreateChangeStreamPostBusinessTypesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        businessTypeDeleteById(params, options) {
            return exports.BusinessTypeApiFp.businessTypeDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        businessTypeExistsGetBusinessTypesidExists(params, options) {
            return exports.BusinessTypeApiFp.businessTypeExistsGetBusinessTypesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        businessTypeExistsHeadBusinessTypesid(params, options) {
            return exports.BusinessTypeApiFp.businessTypeExistsHeadBusinessTypesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        businessTypeFind(params, options) {
            return exports.BusinessTypeApiFp.businessTypeFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        businessTypeFindById(params, options) {
            return exports.BusinessTypeApiFp.businessTypeFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        businessTypeFindOne(params, options) {
            return exports.BusinessTypeApiFp.businessTypeFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        businessTypePatchOrCreate(params, options) {
            return exports.BusinessTypeApiFp.businessTypePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts account of BusinessType.
         * @param id BusinessType id
         * @param where Criteria to match model instances
         */
        businessTypePrototypeCountAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeCountAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in account of this model.
         * @param id BusinessType id
         * @param data
         */
        businessTypePrototypeCreateAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeCreateAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all account of this model.
         * @param id BusinessType id
         */
        businessTypePrototypeDeleteAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeDeleteAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for account.
         * @param id BusinessType id
         * @param fk Foreign key for account
         */
        businessTypePrototypeDestroyByIdAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeDestroyByIdAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for account.
         * @param id BusinessType id
         * @param fk Foreign key for account
         */
        businessTypePrototypeFindByIdAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeFindByIdAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries account of BusinessType.
         * @param id BusinessType id
         * @param filter
         */
        businessTypePrototypeGetAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id BusinessType id
         * @param data An object of model property name/value pairs
         */
        businessTypePrototypePatchAttributes(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for account.
         * @param id BusinessType id
         * @param fk Foreign key for account
         * @param data
         */
        businessTypePrototypeUpdateByIdAccount(params, options) {
            return exports.BusinessTypeApiFp.businessTypePrototypeUpdateByIdAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        businessTypeReplaceByIdPostBusinessTypesidReplace(params, options) {
            return exports.BusinessTypeApiFp.businessTypeReplaceByIdPostBusinessTypesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        businessTypeReplaceByIdPutBusinessTypesid(params, options) {
            return exports.BusinessTypeApiFp.businessTypeReplaceByIdPutBusinessTypesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options) {
            return exports.BusinessTypeApiFp.businessTypeReplaceOrCreatePostBusinessTypesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        businessTypeReplaceOrCreatePutBusinessTypes(params, options) {
            return exports.BusinessTypeApiFp.businessTypeReplaceOrCreatePutBusinessTypes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        businessTypeUpdateAll(params, options) {
            return exports.BusinessTypeApiFp.businessTypeUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        businessTypeUpsertWithWhere(params, options) {
            return exports.BusinessTypeApiFp.businessTypeUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.BusinessTypeApiFactory = BusinessTypeApiFactory;
/**
 * CartApi - fetch parameter creator
 */
exports.CartApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartCount(params, options) {
        const baseUrl = `/Carts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartCreate(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamGetCartsChangeStream(params, options) {
        const baseUrl = `/Carts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamPostCartsChangeStream(params, options) {
        const baseUrl = `/Carts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartDeleteById');
        }
        const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsGetCartsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartExistsGetCartsidExists');
        }
        const baseUrl = `/Carts/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsHeadCartsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartExistsHeadCartsid');
        }
        const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFind(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartFindById');
        }
        const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFindOne(params, options) {
        const baseUrl = `/Carts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartPatchOrCreate(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts tracks of Cart.
     * @param id Cart id
     * @param where Criteria to match model instances
     */
    cartPrototypeCountTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeCountTracks');
        }
        const baseUrl = `/Carts/{id}/tracks/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in tracks of this model.
     * @param id Cart id
     * @param data
     */
    cartPrototypeCreateTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeCreateTracks');
        }
        const baseUrl = `/Carts/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all tracks of this model.
     * @param id Cart id
     */
    cartPrototypeDeleteTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeDeleteTracks');
        }
        const baseUrl = `/Carts/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     */
    cartPrototypeDestroyByIdTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeDestroyByIdTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling cartPrototypeDestroyByIdTracks');
        }
        const baseUrl = `/Carts/{id}/tracks/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     */
    cartPrototypeFindByIdTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeFindByIdTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling cartPrototypeFindByIdTracks');
        }
        const baseUrl = `/Carts/{id}/tracks/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Cart id
     * @param refresh
     */
    cartPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeGetAccount');
        }
        const baseUrl = `/Carts/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries tracks of Cart.
     * @param id Cart id
     * @param filter
     */
    cartPrototypeGetTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeGetTracks');
        }
        const baseUrl = `/Carts/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Cart id
     * @param data An object of model property name/value pairs
     */
    cartPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypePatchAttributes');
        }
        const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     * @param data
     */
    cartPrototypeUpdateByIdTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartPrototypeUpdateByIdTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling cartPrototypeUpdateByIdTracks');
        }
        const baseUrl = `/Carts/{id}/tracks/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPostCartsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartReplaceByIdPostCartsidReplace');
        }
        const baseUrl = `/Carts/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPutCartsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling cartReplaceByIdPutCartsid');
        }
        const baseUrl = `/Carts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
        const baseUrl = `/Carts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePutCarts(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpdateAll(params, options) {
        const baseUrl = `/Carts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpsertWithWhere(params, options) {
        const baseUrl = `/Carts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * CartApi - functional programming interface
 */
exports.CartApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartCount(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartCreate(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamGetCartsChangeStream(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCreateChangeStreamGetCartsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamPostCartsChangeStream(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCreateChangeStreamPostCartsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartDeleteById(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsGetCartsidExists(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartExistsGetCartsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsHeadCartsid(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartExistsHeadCartsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFind(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartFindById(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFindOne(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartPatchOrCreate(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts tracks of Cart.
     * @param id Cart id
     * @param where Criteria to match model instances
     */
    cartPrototypeCountTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeCountTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in tracks of this model.
     * @param id Cart id
     * @param data
     */
    cartPrototypeCreateTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeCreateTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all tracks of this model.
     * @param id Cart id
     */
    cartPrototypeDeleteTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeDeleteTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     */
    cartPrototypeDestroyByIdTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeDestroyByIdTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     */
    cartPrototypeFindByIdTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeFindByIdTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Cart id
     * @param refresh
     */
    cartPrototypeGetAccount(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries tracks of Cart.
     * @param id Cart id
     * @param filter
     */
    cartPrototypeGetTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeGetTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Cart id
     * @param data An object of model property name/value pairs
     */
    cartPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     * @param data
     */
    cartPrototypeUpdateByIdTracks(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeUpdateByIdTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPostCartsidReplace(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceByIdPostCartsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPutCartsid(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceByIdPutCartsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePutCarts(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceOrCreatePutCarts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpdateAll(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpsertWithWhere(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * CartApi - object-oriented interface
 */
class CartApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartCount(params, options) {
        return exports.CartApiFp.cartCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartCreate(params, options) {
        return exports.CartApiFp.cartCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamGetCartsChangeStream(params, options) {
        return exports.CartApiFp.cartCreateChangeStreamGetCartsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamPostCartsChangeStream(params, options) {
        return exports.CartApiFp.cartCreateChangeStreamPostCartsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartDeleteById(params, options) {
        return exports.CartApiFp.cartDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsGetCartsidExists(params, options) {
        return exports.CartApiFp.cartExistsGetCartsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsHeadCartsid(params, options) {
        return exports.CartApiFp.cartExistsHeadCartsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFind(params, options) {
        return exports.CartApiFp.cartFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartFindById(params, options) {
        return exports.CartApiFp.cartFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFindOne(params, options) {
        return exports.CartApiFp.cartFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartPatchOrCreate(params, options) {
        return exports.CartApiFp.cartPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts tracks of Cart.
     * @param id Cart id
     * @param where Criteria to match model instances
     */
    cartPrototypeCountTracks(params, options) {
        return exports.CartApiFp.cartPrototypeCountTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in tracks of this model.
     * @param id Cart id
     * @param data
     */
    cartPrototypeCreateTracks(params, options) {
        return exports.CartApiFp.cartPrototypeCreateTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all tracks of this model.
     * @param id Cart id
     */
    cartPrototypeDeleteTracks(params, options) {
        return exports.CartApiFp.cartPrototypeDeleteTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     */
    cartPrototypeDestroyByIdTracks(params, options) {
        return exports.CartApiFp.cartPrototypeDestroyByIdTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     */
    cartPrototypeFindByIdTracks(params, options) {
        return exports.CartApiFp.cartPrototypeFindByIdTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Cart id
     * @param refresh
     */
    cartPrototypeGetAccount(params, options) {
        return exports.CartApiFp.cartPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries tracks of Cart.
     * @param id Cart id
     * @param filter
     */
    cartPrototypeGetTracks(params, options) {
        return exports.CartApiFp.cartPrototypeGetTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Cart id
     * @param data An object of model property name/value pairs
     */
    cartPrototypePatchAttributes(params, options) {
        return exports.CartApiFp.cartPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for tracks.
     * @param id Cart id
     * @param fk Foreign key for tracks
     * @param data
     */
    cartPrototypeUpdateByIdTracks(params, options) {
        return exports.CartApiFp.cartPrototypeUpdateByIdTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPostCartsidReplace(params, options) {
        return exports.CartApiFp.cartReplaceByIdPostCartsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPutCartsid(params, options) {
        return exports.CartApiFp.cartReplaceByIdPutCartsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
        return exports.CartApiFp.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePutCarts(params, options) {
        return exports.CartApiFp.cartReplaceOrCreatePutCarts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpdateAll(params, options) {
        return exports.CartApiFp.cartUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpsertWithWhere(params, options) {
        return exports.CartApiFp.cartUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.CartApi = CartApi;
/**
 * CartApi - factory interface
 */
const CartApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        cartCount(params, options) {
            return exports.CartApiFp.cartCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        cartCreate(params, options) {
            return exports.CartApiFp.cartCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        cartCreateChangeStreamGetCartsChangeStream(params, options) {
            return exports.CartApiFp.cartCreateChangeStreamGetCartsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        cartCreateChangeStreamPostCartsChangeStream(params, options) {
            return exports.CartApiFp.cartCreateChangeStreamPostCartsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        cartDeleteById(params, options) {
            return exports.CartApiFp.cartDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        cartExistsGetCartsidExists(params, options) {
            return exports.CartApiFp.cartExistsGetCartsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        cartExistsHeadCartsid(params, options) {
            return exports.CartApiFp.cartExistsHeadCartsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        cartFind(params, options) {
            return exports.CartApiFp.cartFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        cartFindById(params, options) {
            return exports.CartApiFp.cartFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        cartFindOne(params, options) {
            return exports.CartApiFp.cartFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartPatchOrCreate(params, options) {
            return exports.CartApiFp.cartPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts tracks of Cart.
         * @param id Cart id
         * @param where Criteria to match model instances
         */
        cartPrototypeCountTracks(params, options) {
            return exports.CartApiFp.cartPrototypeCountTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in tracks of this model.
         * @param id Cart id
         * @param data
         */
        cartPrototypeCreateTracks(params, options) {
            return exports.CartApiFp.cartPrototypeCreateTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all tracks of this model.
         * @param id Cart id
         */
        cartPrototypeDeleteTracks(params, options) {
            return exports.CartApiFp.cartPrototypeDeleteTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for tracks.
         * @param id Cart id
         * @param fk Foreign key for tracks
         */
        cartPrototypeDestroyByIdTracks(params, options) {
            return exports.CartApiFp.cartPrototypeDestroyByIdTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for tracks.
         * @param id Cart id
         * @param fk Foreign key for tracks
         */
        cartPrototypeFindByIdTracks(params, options) {
            return exports.CartApiFp.cartPrototypeFindByIdTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Cart id
         * @param refresh
         */
        cartPrototypeGetAccount(params, options) {
            return exports.CartApiFp.cartPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries tracks of Cart.
         * @param id Cart id
         * @param filter
         */
        cartPrototypeGetTracks(params, options) {
            return exports.CartApiFp.cartPrototypeGetTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Cart id
         * @param data An object of model property name/value pairs
         */
        cartPrototypePatchAttributes(params, options) {
            return exports.CartApiFp.cartPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for tracks.
         * @param id Cart id
         * @param fk Foreign key for tracks
         * @param data
         */
        cartPrototypeUpdateByIdTracks(params, options) {
            return exports.CartApiFp.cartPrototypeUpdateByIdTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        cartReplaceByIdPostCartsidReplace(params, options) {
            return exports.CartApiFp.cartReplaceByIdPostCartsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        cartReplaceByIdPutCartsid(params, options) {
            return exports.CartApiFp.cartReplaceByIdPutCartsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
            return exports.CartApiFp.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartReplaceOrCreatePutCarts(params, options) {
            return exports.CartApiFp.cartReplaceOrCreatePutCarts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        cartUpdateAll(params, options) {
            return exports.CartApiFp.cartUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        cartUpsertWithWhere(params, options) {
            return exports.CartApiFp.cartUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.CartApiFactory = CartApiFactory;
/**
 * ComposeTrackApi - fetch parameter creator
 */
exports.ComposeTrackApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    composeTrackCount(params, options) {
        const baseUrl = `/ComposeTracks/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    composeTrackCreate(params, options) {
        const baseUrl = `/ComposeTracks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options) {
        const baseUrl = `/ComposeTracks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options) {
        const baseUrl = `/ComposeTracks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    composeTrackDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackDeleteById');
        }
        const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    composeTrackExistsGetComposeTracksidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackExistsGetComposeTracksidExists');
        }
        const baseUrl = `/ComposeTracks/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    composeTrackExistsHeadComposeTracksid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackExistsHeadComposeTracksid');
        }
        const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    composeTrackFind(params, options) {
        const baseUrl = `/ComposeTracks`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    composeTrackFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackFindById');
        }
        const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    composeTrackFindOne(params, options) {
        const baseUrl = `/ComposeTracks/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackPatchOrCreate(params, options) {
        const baseUrl = `/ComposeTracks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id ComposeTrack id
     * @param refresh
     */
    composeTrackPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackPrototypeGetAccount');
        }
        const baseUrl = `/ComposeTracks/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id ComposeTrack id
     * @param refresh
     */
    composeTrackPrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackPrototypeGetTrack');
        }
        const baseUrl = `/ComposeTracks/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id ComposeTrack id
     * @param data An object of model property name/value pairs
     */
    composeTrackPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackPrototypePatchAttributes');
        }
        const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    composeTrackReplaceByIdPostComposeTracksidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackReplaceByIdPostComposeTracksidReplace');
        }
        const baseUrl = `/ComposeTracks/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    composeTrackReplaceByIdPutComposeTracksid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling composeTrackReplaceByIdPutComposeTracksid');
        }
        const baseUrl = `/ComposeTracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options) {
        const baseUrl = `/ComposeTracks/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackReplaceOrCreatePutComposeTracks(params, options) {
        const baseUrl = `/ComposeTracks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    composeTrackUpdateAll(params, options) {
        const baseUrl = `/ComposeTracks/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    composeTrackUpsertWithWhere(params, options) {
        const baseUrl = `/ComposeTracks/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ComposeTrackApi - functional programming interface
 */
exports.ComposeTrackApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    composeTrackCount(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    composeTrackCreate(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    composeTrackDeleteById(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    composeTrackExistsGetComposeTracksidExists(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackExistsGetComposeTracksidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    composeTrackExistsHeadComposeTracksid(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackExistsHeadComposeTracksid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    composeTrackFind(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    composeTrackFindById(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    composeTrackFindOne(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackPatchOrCreate(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id ComposeTrack id
     * @param refresh
     */
    composeTrackPrototypeGetAccount(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id ComposeTrack id
     * @param refresh
     */
    composeTrackPrototypeGetTrack(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackPrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id ComposeTrack id
     * @param data An object of model property name/value pairs
     */
    composeTrackPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    composeTrackReplaceByIdPostComposeTracksidReplace(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackReplaceByIdPostComposeTracksidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    composeTrackReplaceByIdPutComposeTracksid(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackReplaceByIdPutComposeTracksid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackReplaceOrCreatePutComposeTracks(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackReplaceOrCreatePutComposeTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    composeTrackUpdateAll(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    composeTrackUpsertWithWhere(params, options) {
        const fetchArgs = exports.ComposeTrackApiFetchParamCreator.composeTrackUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ComposeTrackApi - object-oriented interface
 */
class ComposeTrackApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    composeTrackCount(params, options) {
        return exports.ComposeTrackApiFp.composeTrackCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    composeTrackCreate(params, options) {
        return exports.ComposeTrackApiFp.composeTrackCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options) {
        return exports.ComposeTrackApiFp.composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options) {
        return exports.ComposeTrackApiFp.composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    composeTrackDeleteById(params, options) {
        return exports.ComposeTrackApiFp.composeTrackDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    composeTrackExistsGetComposeTracksidExists(params, options) {
        return exports.ComposeTrackApiFp.composeTrackExistsGetComposeTracksidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    composeTrackExistsHeadComposeTracksid(params, options) {
        return exports.ComposeTrackApiFp.composeTrackExistsHeadComposeTracksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    composeTrackFind(params, options) {
        return exports.ComposeTrackApiFp.composeTrackFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    composeTrackFindById(params, options) {
        return exports.ComposeTrackApiFp.composeTrackFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    composeTrackFindOne(params, options) {
        return exports.ComposeTrackApiFp.composeTrackFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackPatchOrCreate(params, options) {
        return exports.ComposeTrackApiFp.composeTrackPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id ComposeTrack id
     * @param refresh
     */
    composeTrackPrototypeGetAccount(params, options) {
        return exports.ComposeTrackApiFp.composeTrackPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id ComposeTrack id
     * @param refresh
     */
    composeTrackPrototypeGetTrack(params, options) {
        return exports.ComposeTrackApiFp.composeTrackPrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id ComposeTrack id
     * @param data An object of model property name/value pairs
     */
    composeTrackPrototypePatchAttributes(params, options) {
        return exports.ComposeTrackApiFp.composeTrackPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    composeTrackReplaceByIdPostComposeTracksidReplace(params, options) {
        return exports.ComposeTrackApiFp.composeTrackReplaceByIdPostComposeTracksidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    composeTrackReplaceByIdPutComposeTracksid(params, options) {
        return exports.ComposeTrackApiFp.composeTrackReplaceByIdPutComposeTracksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options) {
        return exports.ComposeTrackApiFp.composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    composeTrackReplaceOrCreatePutComposeTracks(params, options) {
        return exports.ComposeTrackApiFp.composeTrackReplaceOrCreatePutComposeTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    composeTrackUpdateAll(params, options) {
        return exports.ComposeTrackApiFp.composeTrackUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    composeTrackUpsertWithWhere(params, options) {
        return exports.ComposeTrackApiFp.composeTrackUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ComposeTrackApi = ComposeTrackApi;
/**
 * ComposeTrackApi - factory interface
 */
const ComposeTrackApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        composeTrackCount(params, options) {
            return exports.ComposeTrackApiFp.composeTrackCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        composeTrackCreate(params, options) {
            return exports.ComposeTrackApiFp.composeTrackCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options) {
            return exports.ComposeTrackApiFp.composeTrackCreateChangeStreamGetComposeTracksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options) {
            return exports.ComposeTrackApiFp.composeTrackCreateChangeStreamPostComposeTracksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        composeTrackDeleteById(params, options) {
            return exports.ComposeTrackApiFp.composeTrackDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        composeTrackExistsGetComposeTracksidExists(params, options) {
            return exports.ComposeTrackApiFp.composeTrackExistsGetComposeTracksidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        composeTrackExistsHeadComposeTracksid(params, options) {
            return exports.ComposeTrackApiFp.composeTrackExistsHeadComposeTracksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        composeTrackFind(params, options) {
            return exports.ComposeTrackApiFp.composeTrackFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        composeTrackFindById(params, options) {
            return exports.ComposeTrackApiFp.composeTrackFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        composeTrackFindOne(params, options) {
            return exports.ComposeTrackApiFp.composeTrackFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        composeTrackPatchOrCreate(params, options) {
            return exports.ComposeTrackApiFp.composeTrackPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id ComposeTrack id
         * @param refresh
         */
        composeTrackPrototypeGetAccount(params, options) {
            return exports.ComposeTrackApiFp.composeTrackPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation track.
         * @param id ComposeTrack id
         * @param refresh
         */
        composeTrackPrototypeGetTrack(params, options) {
            return exports.ComposeTrackApiFp.composeTrackPrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id ComposeTrack id
         * @param data An object of model property name/value pairs
         */
        composeTrackPrototypePatchAttributes(params, options) {
            return exports.ComposeTrackApiFp.composeTrackPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        composeTrackReplaceByIdPostComposeTracksidReplace(params, options) {
            return exports.ComposeTrackApiFp.composeTrackReplaceByIdPostComposeTracksidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        composeTrackReplaceByIdPutComposeTracksid(params, options) {
            return exports.ComposeTrackApiFp.composeTrackReplaceByIdPutComposeTracksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options) {
            return exports.ComposeTrackApiFp.composeTrackReplaceOrCreatePostComposeTracksReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        composeTrackReplaceOrCreatePutComposeTracks(params, options) {
            return exports.ComposeTrackApiFp.composeTrackReplaceOrCreatePutComposeTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        composeTrackUpdateAll(params, options) {
            return exports.ComposeTrackApiFp.composeTrackUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        composeTrackUpsertWithWhere(params, options) {
            return exports.ComposeTrackApiFp.composeTrackUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ComposeTrackApiFactory = ComposeTrackApiFactory;
/**
 * ContainerApi - fetch parameter creator
 */
exports.ContainerApiFetchParamCreator = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['options']) {
            fetchOptions.body = JSON.stringify(params['options'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerDestroyContainer');
        }
        const baseUrl = `/Containers/{container}`.replace(`{${'container'}}`, `${params['container']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerDownload');
        }
        // verify required parameter "file" is set
        if (params['file'] == null) {
            throw new Error('Missing required parameter file when calling containerDownload');
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${'container'}}`, `${params['container']}`)
            .replace(`{${'file'}}`, `${params['file']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerGetContainer');
        }
        const baseUrl = `/Containers/{container}`.replace(`{${'container'}}`, `${params['container']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerGetFile');
        }
        // verify required parameter "file" is set
        if (params['file'] == null) {
            throw new Error('Missing required parameter file when calling containerGetFile');
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${'container'}}`, `${params['container']}`)
            .replace(`{${'file'}}`, `${params['file']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerGetFiles');
        }
        const baseUrl = `/Containers/{container}/files`.replace(`{${'container'}}`, `${params['container']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerRemoveFile');
        }
        // verify required parameter "file" is set
        if (params['file'] == null) {
            throw new Error('Missing required parameter file when calling containerRemoveFile');
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${'container'}}`, `${params['container']}`)
            .replace(`{${'file'}}`, `${params['file']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        // verify required parameter "container" is set
        if (params['container'] == null) {
            throw new Error('Missing required parameter container when calling containerUpload');
        }
        const baseUrl = `/Containers/{container}/upload`.replace(`{${'container'}}`, `${params['container']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ContainerApi - functional programming interface
 */
exports.ContainerApiFp = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ContainerApi - object-oriented interface
 */
class ContainerApi extends BaseAPI {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        return exports.ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        return exports.ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        return exports.ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        return exports.ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     */
    containerGetContainers(options) {
        return exports.ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        return exports.ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        return exports.ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        return exports.ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        return exports.ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
}
exports.ContainerApi = ContainerApi;
/**
 * ContainerApi - factory interface
 */
const ContainerApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @param options
         */
        containerCreateContainer(params, options) {
            return exports.ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerDestroyContainer(params, options) {
            return exports.ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerDownload(params, options) {
            return exports.ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetContainer(params, options) {
            return exports.ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         *
         */
        containerGetContainers(options) {
            return exports.ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerGetFile(params, options) {
            return exports.ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetFiles(params, options) {
            return exports.ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerRemoveFile(params, options) {
            return exports.ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerUpload(params, options) {
            return exports.ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};
exports.ContainerApiFactory = ContainerApiFactory;
/**
 * DownloadApi - fetch parameter creator
 */
exports.DownloadApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    downloadCount(params, options) {
        const baseUrl = `/Downloads/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    downloadCreate(params, options) {
        const baseUrl = `/Downloads`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    downloadCreateChangeStreamGetDownloadsChangeStream(params, options) {
        const baseUrl = `/Downloads/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    downloadCreateChangeStreamPostDownloadsChangeStream(params, options) {
        const baseUrl = `/Downloads/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    downloadDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadDeleteById');
        }
        const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    downloadExistsGetDownloadsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadExistsGetDownloadsidExists');
        }
        const baseUrl = `/Downloads/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    downloadExistsHeadDownloadsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadExistsHeadDownloadsid');
        }
        const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    downloadFind(params, options) {
        const baseUrl = `/Downloads`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    downloadFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadFindById');
        }
        const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    downloadFindOne(params, options) {
        const baseUrl = `/Downloads/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadPatchOrCreate(params, options) {
        const baseUrl = `/Downloads`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation listeners.
     * @param id Download id
     * @param refresh
     */
    downloadPrototypeGetListeners(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadPrototypeGetListeners');
        }
        const baseUrl = `/Downloads/{id}/listeners`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation trackDownload.
     * @param id Download id
     * @param refresh
     */
    downloadPrototypeGetTrackDownload(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadPrototypeGetTrackDownload');
        }
        const baseUrl = `/Downloads/{id}/trackDownload`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Download id
     * @param data An object of model property name/value pairs
     */
    downloadPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadPrototypePatchAttributes');
        }
        const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    downloadReplaceByIdPostDownloadsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadReplaceByIdPostDownloadsidReplace');
        }
        const baseUrl = `/Downloads/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    downloadReplaceByIdPutDownloadsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadReplaceByIdPutDownloadsid');
        }
        const baseUrl = `/Downloads/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options) {
        const baseUrl = `/Downloads/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadReplaceOrCreatePutDownloads(params, options) {
        const baseUrl = `/Downloads`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    downloadUpdateAll(params, options) {
        const baseUrl = `/Downloads/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    downloadUpsertWithWhere(params, options) {
        const baseUrl = `/Downloads/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * DownloadApi - functional programming interface
 */
exports.DownloadApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    downloadCount(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    downloadCreate(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    downloadCreateChangeStreamGetDownloadsChangeStream(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadCreateChangeStreamGetDownloadsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    downloadCreateChangeStreamPostDownloadsChangeStream(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadCreateChangeStreamPostDownloadsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    downloadDeleteById(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    downloadExistsGetDownloadsidExists(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadExistsGetDownloadsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    downloadExistsHeadDownloadsid(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadExistsHeadDownloadsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    downloadFind(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    downloadFindById(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    downloadFindOne(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadPatchOrCreate(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation listeners.
     * @param id Download id
     * @param refresh
     */
    downloadPrototypeGetListeners(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadPrototypeGetListeners(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation trackDownload.
     * @param id Download id
     * @param refresh
     */
    downloadPrototypeGetTrackDownload(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadPrototypeGetTrackDownload(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Download id
     * @param data An object of model property name/value pairs
     */
    downloadPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    downloadReplaceByIdPostDownloadsidReplace(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadReplaceByIdPostDownloadsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    downloadReplaceByIdPutDownloadsid(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadReplaceByIdPutDownloadsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadReplaceOrCreatePutDownloads(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadReplaceOrCreatePutDownloads(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    downloadUpdateAll(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    downloadUpsertWithWhere(params, options) {
        const fetchArgs = exports.DownloadApiFetchParamCreator.downloadUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * DownloadApi - object-oriented interface
 */
class DownloadApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    downloadCount(params, options) {
        return exports.DownloadApiFp.downloadCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    downloadCreate(params, options) {
        return exports.DownloadApiFp.downloadCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    downloadCreateChangeStreamGetDownloadsChangeStream(params, options) {
        return exports.DownloadApiFp.downloadCreateChangeStreamGetDownloadsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    downloadCreateChangeStreamPostDownloadsChangeStream(params, options) {
        return exports.DownloadApiFp.downloadCreateChangeStreamPostDownloadsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    downloadDeleteById(params, options) {
        return exports.DownloadApiFp.downloadDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    downloadExistsGetDownloadsidExists(params, options) {
        return exports.DownloadApiFp.downloadExistsGetDownloadsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    downloadExistsHeadDownloadsid(params, options) {
        return exports.DownloadApiFp.downloadExistsHeadDownloadsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    downloadFind(params, options) {
        return exports.DownloadApiFp.downloadFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    downloadFindById(params, options) {
        return exports.DownloadApiFp.downloadFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    downloadFindOne(params, options) {
        return exports.DownloadApiFp.downloadFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadPatchOrCreate(params, options) {
        return exports.DownloadApiFp.downloadPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation listeners.
     * @param id Download id
     * @param refresh
     */
    downloadPrototypeGetListeners(params, options) {
        return exports.DownloadApiFp.downloadPrototypeGetListeners(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation trackDownload.
     * @param id Download id
     * @param refresh
     */
    downloadPrototypeGetTrackDownload(params, options) {
        return exports.DownloadApiFp.downloadPrototypeGetTrackDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Download id
     * @param data An object of model property name/value pairs
     */
    downloadPrototypePatchAttributes(params, options) {
        return exports.DownloadApiFp.downloadPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    downloadReplaceByIdPostDownloadsidReplace(params, options) {
        return exports.DownloadApiFp.downloadReplaceByIdPostDownloadsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    downloadReplaceByIdPutDownloadsid(params, options) {
        return exports.DownloadApiFp.downloadReplaceByIdPutDownloadsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options) {
        return exports.DownloadApiFp.downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    downloadReplaceOrCreatePutDownloads(params, options) {
        return exports.DownloadApiFp.downloadReplaceOrCreatePutDownloads(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    downloadUpdateAll(params, options) {
        return exports.DownloadApiFp.downloadUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    downloadUpsertWithWhere(params, options) {
        return exports.DownloadApiFp.downloadUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.DownloadApi = DownloadApi;
/**
 * DownloadApi - factory interface
 */
const DownloadApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        downloadCount(params, options) {
            return exports.DownloadApiFp.downloadCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        downloadCreate(params, options) {
            return exports.DownloadApiFp.downloadCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        downloadCreateChangeStreamGetDownloadsChangeStream(params, options) {
            return exports.DownloadApiFp.downloadCreateChangeStreamGetDownloadsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        downloadCreateChangeStreamPostDownloadsChangeStream(params, options) {
            return exports.DownloadApiFp.downloadCreateChangeStreamPostDownloadsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        downloadDeleteById(params, options) {
            return exports.DownloadApiFp.downloadDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        downloadExistsGetDownloadsidExists(params, options) {
            return exports.DownloadApiFp.downloadExistsGetDownloadsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        downloadExistsHeadDownloadsid(params, options) {
            return exports.DownloadApiFp.downloadExistsHeadDownloadsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        downloadFind(params, options) {
            return exports.DownloadApiFp.downloadFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        downloadFindById(params, options) {
            return exports.DownloadApiFp.downloadFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        downloadFindOne(params, options) {
            return exports.DownloadApiFp.downloadFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        downloadPatchOrCreate(params, options) {
            return exports.DownloadApiFp.downloadPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation listeners.
         * @param id Download id
         * @param refresh
         */
        downloadPrototypeGetListeners(params, options) {
            return exports.DownloadApiFp.downloadPrototypeGetListeners(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation trackDownload.
         * @param id Download id
         * @param refresh
         */
        downloadPrototypeGetTrackDownload(params, options) {
            return exports.DownloadApiFp.downloadPrototypeGetTrackDownload(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Download id
         * @param data An object of model property name/value pairs
         */
        downloadPrototypePatchAttributes(params, options) {
            return exports.DownloadApiFp.downloadPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        downloadReplaceByIdPostDownloadsidReplace(params, options) {
            return exports.DownloadApiFp.downloadReplaceByIdPostDownloadsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        downloadReplaceByIdPutDownloadsid(params, options) {
            return exports.DownloadApiFp.downloadReplaceByIdPutDownloadsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options) {
            return exports.DownloadApiFp.downloadReplaceOrCreatePostDownloadsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        downloadReplaceOrCreatePutDownloads(params, options) {
            return exports.DownloadApiFp.downloadReplaceOrCreatePutDownloads(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        downloadUpdateAll(params, options) {
            return exports.DownloadApiFp.downloadUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        downloadUpsertWithWhere(params, options) {
            return exports.DownloadApiFp.downloadUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.DownloadApiFactory = DownloadApiFactory;
/**
 * FeatureApi - fetch parameter creator
 */
exports.FeatureApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    featureCount(params, options) {
        const baseUrl = `/Features/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    featureCreate(params, options) {
        const baseUrl = `/Features`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    featureCreateChangeStreamGetFeaturesChangeStream(params, options) {
        const baseUrl = `/Features/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    featureCreateChangeStreamPostFeaturesChangeStream(params, options) {
        const baseUrl = `/Features/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    featureDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featureDeleteById');
        }
        const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    featureExistsGetFeaturesidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featureExistsGetFeaturesidExists');
        }
        const baseUrl = `/Features/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    featureExistsHeadFeaturesid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featureExistsHeadFeaturesid');
        }
        const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    featureFind(params, options) {
        const baseUrl = `/Features`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    featureFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featureFindById');
        }
        const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    featureFindOne(params, options) {
        const baseUrl = `/Features/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featurePatchOrCreate(params, options) {
        const baseUrl = `/Features`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts track of Feature.
     * @param id Feature id
     * @param where Criteria to match model instances
     */
    featurePrototypeCountTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeCountTrack');
        }
        const baseUrl = `/Features/{id}/track/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Feature id
     * @param data
     */
    featurePrototypeCreateTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeCreateTrack');
        }
        const baseUrl = `/Features/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Feature id
     */
    featurePrototypeDeleteTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeDeleteTrack');
        }
        const baseUrl = `/Features/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeDestroyByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeDestroyByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling featurePrototypeDestroyByIdTrack');
        }
        const baseUrl = `/Features/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeExistsTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeExistsTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling featurePrototypeExistsTrack');
        }
        const baseUrl = `/Features/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeFindByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeFindByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling featurePrototypeFindByIdTrack');
        }
        const baseUrl = `/Features/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feature id
     * @param refresh
     */
    featurePrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeGetAccount');
        }
        const baseUrl = `/Features/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries track of Feature.
     * @param id Feature id
     * @param filter
     */
    featurePrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeGetTrack');
        }
        const baseUrl = `/Features/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     * @param data
     */
    featurePrototypeLinkTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeLinkTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling featurePrototypeLinkTrack');
        }
        const baseUrl = `/Features/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feature id
     * @param data An object of model property name/value pairs
     */
    featurePrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypePatchAttributes');
        }
        const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeUnlinkTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeUnlinkTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling featurePrototypeUnlinkTrack');
        }
        const baseUrl = `/Features/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     * @param data
     */
    featurePrototypeUpdateByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featurePrototypeUpdateByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling featurePrototypeUpdateByIdTrack');
        }
        const baseUrl = `/Features/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    featureReplaceByIdPostFeaturesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featureReplaceByIdPostFeaturesidReplace');
        }
        const baseUrl = `/Features/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    featureReplaceByIdPutFeaturesid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling featureReplaceByIdPutFeaturesid');
        }
        const baseUrl = `/Features/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options) {
        const baseUrl = `/Features/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featureReplaceOrCreatePutFeatures(params, options) {
        const baseUrl = `/Features`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    featureUpdateAll(params, options) {
        const baseUrl = `/Features/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    featureUpsertWithWhere(params, options) {
        const baseUrl = `/Features/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * FeatureApi - functional programming interface
 */
exports.FeatureApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    featureCount(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    featureCreate(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    featureCreateChangeStreamGetFeaturesChangeStream(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureCreateChangeStreamGetFeaturesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    featureCreateChangeStreamPostFeaturesChangeStream(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureCreateChangeStreamPostFeaturesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    featureDeleteById(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    featureExistsGetFeaturesidExists(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureExistsGetFeaturesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    featureExistsHeadFeaturesid(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureExistsHeadFeaturesid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    featureFind(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    featureFindById(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    featureFindOne(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featurePatchOrCreate(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts track of Feature.
     * @param id Feature id
     * @param where Criteria to match model instances
     */
    featurePrototypeCountTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeCountTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Feature id
     * @param data
     */
    featurePrototypeCreateTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeCreateTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Feature id
     */
    featurePrototypeDeleteTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeDeleteTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeDestroyByIdTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeDestroyByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeExistsTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeExistsTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeFindByIdTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeFindByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feature id
     * @param refresh
     */
    featurePrototypeGetAccount(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries track of Feature.
     * @param id Feature id
     * @param filter
     */
    featurePrototypeGetTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     * @param data
     */
    featurePrototypeLinkTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeLinkTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feature id
     * @param data An object of model property name/value pairs
     */
    featurePrototypePatchAttributes(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeUnlinkTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeUnlinkTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     * @param data
     */
    featurePrototypeUpdateByIdTrack(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featurePrototypeUpdateByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    featureReplaceByIdPostFeaturesidReplace(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureReplaceByIdPostFeaturesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    featureReplaceByIdPutFeaturesid(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureReplaceByIdPutFeaturesid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featureReplaceOrCreatePutFeatures(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureReplaceOrCreatePutFeatures(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    featureUpdateAll(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    featureUpsertWithWhere(params, options) {
        const fetchArgs = exports.FeatureApiFetchParamCreator.featureUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * FeatureApi - object-oriented interface
 */
class FeatureApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    featureCount(params, options) {
        return exports.FeatureApiFp.featureCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    featureCreate(params, options) {
        return exports.FeatureApiFp.featureCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    featureCreateChangeStreamGetFeaturesChangeStream(params, options) {
        return exports.FeatureApiFp.featureCreateChangeStreamGetFeaturesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    featureCreateChangeStreamPostFeaturesChangeStream(params, options) {
        return exports.FeatureApiFp.featureCreateChangeStreamPostFeaturesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    featureDeleteById(params, options) {
        return exports.FeatureApiFp.featureDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    featureExistsGetFeaturesidExists(params, options) {
        return exports.FeatureApiFp.featureExistsGetFeaturesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    featureExistsHeadFeaturesid(params, options) {
        return exports.FeatureApiFp.featureExistsHeadFeaturesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    featureFind(params, options) {
        return exports.FeatureApiFp.featureFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    featureFindById(params, options) {
        return exports.FeatureApiFp.featureFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    featureFindOne(params, options) {
        return exports.FeatureApiFp.featureFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featurePatchOrCreate(params, options) {
        return exports.FeatureApiFp.featurePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts track of Feature.
     * @param id Feature id
     * @param where Criteria to match model instances
     */
    featurePrototypeCountTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeCountTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Feature id
     * @param data
     */
    featurePrototypeCreateTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeCreateTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Feature id
     */
    featurePrototypeDeleteTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeDeleteTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeDestroyByIdTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeDestroyByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeExistsTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeExistsTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeFindByIdTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeFindByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feature id
     * @param refresh
     */
    featurePrototypeGetAccount(params, options) {
        return exports.FeatureApiFp.featurePrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries track of Feature.
     * @param id Feature id
     * @param filter
     */
    featurePrototypeGetTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     * @param data
     */
    featurePrototypeLinkTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeLinkTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feature id
     * @param data An object of model property name/value pairs
     */
    featurePrototypePatchAttributes(params, options) {
        return exports.FeatureApiFp.featurePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Feature id
     * @param fk Foreign key for track
     */
    featurePrototypeUnlinkTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeUnlinkTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Feature id
     * @param fk Foreign key for track
     * @param data
     */
    featurePrototypeUpdateByIdTrack(params, options) {
        return exports.FeatureApiFp.featurePrototypeUpdateByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    featureReplaceByIdPostFeaturesidReplace(params, options) {
        return exports.FeatureApiFp.featureReplaceByIdPostFeaturesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    featureReplaceByIdPutFeaturesid(params, options) {
        return exports.FeatureApiFp.featureReplaceByIdPutFeaturesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options) {
        return exports.FeatureApiFp.featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    featureReplaceOrCreatePutFeatures(params, options) {
        return exports.FeatureApiFp.featureReplaceOrCreatePutFeatures(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    featureUpdateAll(params, options) {
        return exports.FeatureApiFp.featureUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    featureUpsertWithWhere(params, options) {
        return exports.FeatureApiFp.featureUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.FeatureApi = FeatureApi;
/**
 * FeatureApi - factory interface
 */
const FeatureApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        featureCount(params, options) {
            return exports.FeatureApiFp.featureCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        featureCreate(params, options) {
            return exports.FeatureApiFp.featureCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        featureCreateChangeStreamGetFeaturesChangeStream(params, options) {
            return exports.FeatureApiFp.featureCreateChangeStreamGetFeaturesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        featureCreateChangeStreamPostFeaturesChangeStream(params, options) {
            return exports.FeatureApiFp.featureCreateChangeStreamPostFeaturesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        featureDeleteById(params, options) {
            return exports.FeatureApiFp.featureDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        featureExistsGetFeaturesidExists(params, options) {
            return exports.FeatureApiFp.featureExistsGetFeaturesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        featureExistsHeadFeaturesid(params, options) {
            return exports.FeatureApiFp.featureExistsHeadFeaturesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        featureFind(params, options) {
            return exports.FeatureApiFp.featureFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        featureFindById(params, options) {
            return exports.FeatureApiFp.featureFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        featureFindOne(params, options) {
            return exports.FeatureApiFp.featureFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        featurePatchOrCreate(params, options) {
            return exports.FeatureApiFp.featurePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts track of Feature.
         * @param id Feature id
         * @param where Criteria to match model instances
         */
        featurePrototypeCountTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeCountTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in track of this model.
         * @param id Feature id
         * @param data
         */
        featurePrototypeCreateTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeCreateTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all track of this model.
         * @param id Feature id
         */
        featurePrototypeDeleteTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeDeleteTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for track.
         * @param id Feature id
         * @param fk Foreign key for track
         */
        featurePrototypeDestroyByIdTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeDestroyByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of track relation to an item by id.
         * @param id Feature id
         * @param fk Foreign key for track
         */
        featurePrototypeExistsTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeExistsTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for track.
         * @param id Feature id
         * @param fk Foreign key for track
         */
        featurePrototypeFindByIdTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeFindByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Feature id
         * @param refresh
         */
        featurePrototypeGetAccount(params, options) {
            return exports.FeatureApiFp.featurePrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries track of Feature.
         * @param id Feature id
         * @param filter
         */
        featurePrototypeGetTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for track.
         * @param id Feature id
         * @param fk Foreign key for track
         * @param data
         */
        featurePrototypeLinkTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeLinkTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Feature id
         * @param data An object of model property name/value pairs
         */
        featurePrototypePatchAttributes(params, options) {
            return exports.FeatureApiFp.featurePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the track relation to an item by id.
         * @param id Feature id
         * @param fk Foreign key for track
         */
        featurePrototypeUnlinkTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeUnlinkTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for track.
         * @param id Feature id
         * @param fk Foreign key for track
         * @param data
         */
        featurePrototypeUpdateByIdTrack(params, options) {
            return exports.FeatureApiFp.featurePrototypeUpdateByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        featureReplaceByIdPostFeaturesidReplace(params, options) {
            return exports.FeatureApiFp.featureReplaceByIdPostFeaturesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        featureReplaceByIdPutFeaturesid(params, options) {
            return exports.FeatureApiFp.featureReplaceByIdPutFeaturesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options) {
            return exports.FeatureApiFp.featureReplaceOrCreatePostFeaturesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        featureReplaceOrCreatePutFeatures(params, options) {
            return exports.FeatureApiFp.featureReplaceOrCreatePutFeatures(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        featureUpdateAll(params, options) {
            return exports.FeatureApiFp.featureUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        featureUpsertWithWhere(params, options) {
            return exports.FeatureApiFp.featureUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.FeatureApiFactory = FeatureApiFactory;
/**
 * GenreApi - fetch parameter creator
 */
exports.GenreApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    genreCount(params, options) {
        const baseUrl = `/Genres/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    genreCreate(params, options) {
        const baseUrl = `/Genres`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    genreCreateChangeStreamGetGenresChangeStream(params, options) {
        const baseUrl = `/Genres/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    genreCreateChangeStreamPostGenresChangeStream(params, options) {
        const baseUrl = `/Genres/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    genreDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genreDeleteById');
        }
        const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    genreExistsGetGenresidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genreExistsGetGenresidExists');
        }
        const baseUrl = `/Genres/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    genreExistsHeadGenresid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genreExistsHeadGenresid');
        }
        const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    genreFind(params, options) {
        const baseUrl = `/Genres`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    genreFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genreFindById');
        }
        const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    genreFindOne(params, options) {
        const baseUrl = `/Genres/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genrePatchOrCreate(params, options) {
        const baseUrl = `/Genres`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts track of Genre.
     * @param id Genre id
     * @param where Criteria to match model instances
     */
    genrePrototypeCountTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeCountTrack');
        }
        const baseUrl = `/Genres/{id}/track/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Genre id
     * @param data
     */
    genrePrototypeCreateTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeCreateTrack');
        }
        const baseUrl = `/Genres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Genre id
     */
    genrePrototypeDeleteTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeDeleteTrack');
        }
        const baseUrl = `/Genres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeDestroyByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeDestroyByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling genrePrototypeDestroyByIdTrack');
        }
        const baseUrl = `/Genres/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeExistsTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeExistsTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling genrePrototypeExistsTrack');
        }
        const baseUrl = `/Genres/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeFindByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeFindByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling genrePrototypeFindByIdTrack');
        }
        const baseUrl = `/Genres/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Genre id
     * @param refresh
     */
    genrePrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeGetAccount');
        }
        const baseUrl = `/Genres/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation fatherGenre.
     * @param id Genre id
     * @param refresh
     */
    genrePrototypeGetFatherGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeGetFatherGenre');
        }
        const baseUrl = `/Genres/{id}/fatherGenre`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries track of Genre.
     * @param id Genre id
     * @param filter
     */
    genrePrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeGetTrack');
        }
        const baseUrl = `/Genres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     * @param data
     */
    genrePrototypeLinkTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeLinkTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling genrePrototypeLinkTrack');
        }
        const baseUrl = `/Genres/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Genre id
     * @param data An object of model property name/value pairs
     */
    genrePrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypePatchAttributes');
        }
        const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeUnlinkTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeUnlinkTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling genrePrototypeUnlinkTrack');
        }
        const baseUrl = `/Genres/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     * @param data
     */
    genrePrototypeUpdateByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genrePrototypeUpdateByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling genrePrototypeUpdateByIdTrack');
        }
        const baseUrl = `/Genres/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    genreReplaceByIdPostGenresidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genreReplaceByIdPostGenresidReplace');
        }
        const baseUrl = `/Genres/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    genreReplaceByIdPutGenresid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling genreReplaceByIdPutGenresid');
        }
        const baseUrl = `/Genres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genreReplaceOrCreatePostGenresReplaceOrCreate(params, options) {
        const baseUrl = `/Genres/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genreReplaceOrCreatePutGenres(params, options) {
        const baseUrl = `/Genres`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    genreUpdateAll(params, options) {
        const baseUrl = `/Genres/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    genreUpsertWithWhere(params, options) {
        const baseUrl = `/Genres/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * GenreApi - functional programming interface
 */
exports.GenreApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    genreCount(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    genreCreate(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    genreCreateChangeStreamGetGenresChangeStream(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreCreateChangeStreamGetGenresChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    genreCreateChangeStreamPostGenresChangeStream(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreCreateChangeStreamPostGenresChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    genreDeleteById(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    genreExistsGetGenresidExists(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreExistsGetGenresidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    genreExistsHeadGenresid(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreExistsHeadGenresid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    genreFind(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    genreFindById(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    genreFindOne(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genrePatchOrCreate(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts track of Genre.
     * @param id Genre id
     * @param where Criteria to match model instances
     */
    genrePrototypeCountTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeCountTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Genre id
     * @param data
     */
    genrePrototypeCreateTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeCreateTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Genre id
     */
    genrePrototypeDeleteTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeDeleteTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeDestroyByIdTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeDestroyByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeExistsTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeExistsTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeFindByIdTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeFindByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Genre id
     * @param refresh
     */
    genrePrototypeGetAccount(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation fatherGenre.
     * @param id Genre id
     * @param refresh
     */
    genrePrototypeGetFatherGenre(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeGetFatherGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries track of Genre.
     * @param id Genre id
     * @param filter
     */
    genrePrototypeGetTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     * @param data
     */
    genrePrototypeLinkTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeLinkTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Genre id
     * @param data An object of model property name/value pairs
     */
    genrePrototypePatchAttributes(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeUnlinkTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeUnlinkTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     * @param data
     */
    genrePrototypeUpdateByIdTrack(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genrePrototypeUpdateByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    genreReplaceByIdPostGenresidReplace(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreReplaceByIdPostGenresidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    genreReplaceByIdPutGenresid(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreReplaceByIdPutGenresid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genreReplaceOrCreatePostGenresReplaceOrCreate(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreReplaceOrCreatePostGenresReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genreReplaceOrCreatePutGenres(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreReplaceOrCreatePutGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    genreUpdateAll(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    genreUpsertWithWhere(params, options) {
        const fetchArgs = exports.GenreApiFetchParamCreator.genreUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * GenreApi - object-oriented interface
 */
class GenreApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    genreCount(params, options) {
        return exports.GenreApiFp.genreCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    genreCreate(params, options) {
        return exports.GenreApiFp.genreCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    genreCreateChangeStreamGetGenresChangeStream(params, options) {
        return exports.GenreApiFp.genreCreateChangeStreamGetGenresChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    genreCreateChangeStreamPostGenresChangeStream(params, options) {
        return exports.GenreApiFp.genreCreateChangeStreamPostGenresChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    genreDeleteById(params, options) {
        return exports.GenreApiFp.genreDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    genreExistsGetGenresidExists(params, options) {
        return exports.GenreApiFp.genreExistsGetGenresidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    genreExistsHeadGenresid(params, options) {
        return exports.GenreApiFp.genreExistsHeadGenresid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    genreFind(params, options) {
        return exports.GenreApiFp.genreFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    genreFindById(params, options) {
        return exports.GenreApiFp.genreFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    genreFindOne(params, options) {
        return exports.GenreApiFp.genreFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genrePatchOrCreate(params, options) {
        return exports.GenreApiFp.genrePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts track of Genre.
     * @param id Genre id
     * @param where Criteria to match model instances
     */
    genrePrototypeCountTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeCountTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Genre id
     * @param data
     */
    genrePrototypeCreateTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeCreateTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Genre id
     */
    genrePrototypeDeleteTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeDeleteTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeDestroyByIdTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeDestroyByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeExistsTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeExistsTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeFindByIdTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeFindByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Genre id
     * @param refresh
     */
    genrePrototypeGetAccount(params, options) {
        return exports.GenreApiFp.genrePrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation fatherGenre.
     * @param id Genre id
     * @param refresh
     */
    genrePrototypeGetFatherGenre(params, options) {
        return exports.GenreApiFp.genrePrototypeGetFatherGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries track of Genre.
     * @param id Genre id
     * @param filter
     */
    genrePrototypeGetTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     * @param data
     */
    genrePrototypeLinkTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeLinkTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Genre id
     * @param data An object of model property name/value pairs
     */
    genrePrototypePatchAttributes(params, options) {
        return exports.GenreApiFp.genrePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Genre id
     * @param fk Foreign key for track
     */
    genrePrototypeUnlinkTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeUnlinkTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Genre id
     * @param fk Foreign key for track
     * @param data
     */
    genrePrototypeUpdateByIdTrack(params, options) {
        return exports.GenreApiFp.genrePrototypeUpdateByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    genreReplaceByIdPostGenresidReplace(params, options) {
        return exports.GenreApiFp.genreReplaceByIdPostGenresidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    genreReplaceByIdPutGenresid(params, options) {
        return exports.GenreApiFp.genreReplaceByIdPutGenresid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genreReplaceOrCreatePostGenresReplaceOrCreate(params, options) {
        return exports.GenreApiFp.genreReplaceOrCreatePostGenresReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    genreReplaceOrCreatePutGenres(params, options) {
        return exports.GenreApiFp.genreReplaceOrCreatePutGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    genreUpdateAll(params, options) {
        return exports.GenreApiFp.genreUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    genreUpsertWithWhere(params, options) {
        return exports.GenreApiFp.genreUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.GenreApi = GenreApi;
/**
 * GenreApi - factory interface
 */
const GenreApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        genreCount(params, options) {
            return exports.GenreApiFp.genreCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        genreCreate(params, options) {
            return exports.GenreApiFp.genreCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        genreCreateChangeStreamGetGenresChangeStream(params, options) {
            return exports.GenreApiFp.genreCreateChangeStreamGetGenresChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        genreCreateChangeStreamPostGenresChangeStream(params, options) {
            return exports.GenreApiFp.genreCreateChangeStreamPostGenresChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        genreDeleteById(params, options) {
            return exports.GenreApiFp.genreDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        genreExistsGetGenresidExists(params, options) {
            return exports.GenreApiFp.genreExistsGetGenresidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        genreExistsHeadGenresid(params, options) {
            return exports.GenreApiFp.genreExistsHeadGenresid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        genreFind(params, options) {
            return exports.GenreApiFp.genreFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        genreFindById(params, options) {
            return exports.GenreApiFp.genreFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        genreFindOne(params, options) {
            return exports.GenreApiFp.genreFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        genrePatchOrCreate(params, options) {
            return exports.GenreApiFp.genrePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts track of Genre.
         * @param id Genre id
         * @param where Criteria to match model instances
         */
        genrePrototypeCountTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeCountTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in track of this model.
         * @param id Genre id
         * @param data
         */
        genrePrototypeCreateTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeCreateTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all track of this model.
         * @param id Genre id
         */
        genrePrototypeDeleteTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeDeleteTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for track.
         * @param id Genre id
         * @param fk Foreign key for track
         */
        genrePrototypeDestroyByIdTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeDestroyByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of track relation to an item by id.
         * @param id Genre id
         * @param fk Foreign key for track
         */
        genrePrototypeExistsTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeExistsTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for track.
         * @param id Genre id
         * @param fk Foreign key for track
         */
        genrePrototypeFindByIdTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeFindByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Genre id
         * @param refresh
         */
        genrePrototypeGetAccount(params, options) {
            return exports.GenreApiFp.genrePrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation fatherGenre.
         * @param id Genre id
         * @param refresh
         */
        genrePrototypeGetFatherGenre(params, options) {
            return exports.GenreApiFp.genrePrototypeGetFatherGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries track of Genre.
         * @param id Genre id
         * @param filter
         */
        genrePrototypeGetTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for track.
         * @param id Genre id
         * @param fk Foreign key for track
         * @param data
         */
        genrePrototypeLinkTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeLinkTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Genre id
         * @param data An object of model property name/value pairs
         */
        genrePrototypePatchAttributes(params, options) {
            return exports.GenreApiFp.genrePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the track relation to an item by id.
         * @param id Genre id
         * @param fk Foreign key for track
         */
        genrePrototypeUnlinkTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeUnlinkTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for track.
         * @param id Genre id
         * @param fk Foreign key for track
         * @param data
         */
        genrePrototypeUpdateByIdTrack(params, options) {
            return exports.GenreApiFp.genrePrototypeUpdateByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        genreReplaceByIdPostGenresidReplace(params, options) {
            return exports.GenreApiFp.genreReplaceByIdPostGenresidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        genreReplaceByIdPutGenresid(params, options) {
            return exports.GenreApiFp.genreReplaceByIdPutGenresid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        genreReplaceOrCreatePostGenresReplaceOrCreate(params, options) {
            return exports.GenreApiFp.genreReplaceOrCreatePostGenresReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        genreReplaceOrCreatePutGenres(params, options) {
            return exports.GenreApiFp.genreReplaceOrCreatePutGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        genreUpdateAll(params, options) {
            return exports.GenreApiFp.genreUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        genreUpsertWithWhere(params, options) {
            return exports.GenreApiFp.genreUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.GenreApiFactory = GenreApiFactory;
/**
 * MoodApi - fetch parameter creator
 */
exports.MoodApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    moodCount(params, options) {
        const baseUrl = `/Moods/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    moodCreate(params, options) {
        const baseUrl = `/Moods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    moodCreateChangeStreamGetMoodsChangeStream(params, options) {
        const baseUrl = `/Moods/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    moodCreateChangeStreamPostMoodsChangeStream(params, options) {
        const baseUrl = `/Moods/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    moodDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodDeleteById');
        }
        const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    moodExistsGetMoodsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodExistsGetMoodsidExists');
        }
        const baseUrl = `/Moods/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    moodExistsHeadMoodsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodExistsHeadMoodsid');
        }
        const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    moodFind(params, options) {
        const baseUrl = `/Moods`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    moodFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodFindById');
        }
        const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    moodFindOne(params, options) {
        const baseUrl = `/Moods/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodPatchOrCreate(params, options) {
        const baseUrl = `/Moods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts track of Mood.
     * @param id Mood id
     * @param where Criteria to match model instances
     */
    moodPrototypeCountTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeCountTrack');
        }
        const baseUrl = `/Moods/{id}/track/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Mood id
     * @param data
     */
    moodPrototypeCreateTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeCreateTrack');
        }
        const baseUrl = `/Moods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Mood id
     */
    moodPrototypeDeleteTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeDeleteTrack');
        }
        const baseUrl = `/Moods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeDestroyByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeDestroyByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling moodPrototypeDestroyByIdTrack');
        }
        const baseUrl = `/Moods/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeExistsTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeExistsTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling moodPrototypeExistsTrack');
        }
        const baseUrl = `/Moods/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeFindByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeFindByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling moodPrototypeFindByIdTrack');
        }
        const baseUrl = `/Moods/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Mood id
     * @param refresh
     */
    moodPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeGetAccount');
        }
        const baseUrl = `/Moods/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries track of Mood.
     * @param id Mood id
     * @param filter
     */
    moodPrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeGetTrack');
        }
        const baseUrl = `/Moods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     * @param data
     */
    moodPrototypeLinkTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeLinkTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling moodPrototypeLinkTrack');
        }
        const baseUrl = `/Moods/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Mood id
     * @param data An object of model property name/value pairs
     */
    moodPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypePatchAttributes');
        }
        const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeUnlinkTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeUnlinkTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling moodPrototypeUnlinkTrack');
        }
        const baseUrl = `/Moods/{id}/track/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     * @param data
     */
    moodPrototypeUpdateByIdTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodPrototypeUpdateByIdTrack');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling moodPrototypeUpdateByIdTrack');
        }
        const baseUrl = `/Moods/{id}/track/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    moodReplaceByIdPostMoodsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodReplaceByIdPostMoodsidReplace');
        }
        const baseUrl = `/Moods/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    moodReplaceByIdPutMoodsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling moodReplaceByIdPutMoodsid');
        }
        const baseUrl = `/Moods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options) {
        const baseUrl = `/Moods/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodReplaceOrCreatePutMoods(params, options) {
        const baseUrl = `/Moods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    moodUpdateAll(params, options) {
        const baseUrl = `/Moods/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    moodUpsertWithWhere(params, options) {
        const baseUrl = `/Moods/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * MoodApi - functional programming interface
 */
exports.MoodApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    moodCount(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    moodCreate(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    moodCreateChangeStreamGetMoodsChangeStream(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodCreateChangeStreamGetMoodsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    moodCreateChangeStreamPostMoodsChangeStream(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodCreateChangeStreamPostMoodsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    moodDeleteById(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    moodExistsGetMoodsidExists(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodExistsGetMoodsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    moodExistsHeadMoodsid(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodExistsHeadMoodsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    moodFind(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    moodFindById(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    moodFindOne(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodPatchOrCreate(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts track of Mood.
     * @param id Mood id
     * @param where Criteria to match model instances
     */
    moodPrototypeCountTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeCountTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Mood id
     * @param data
     */
    moodPrototypeCreateTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeCreateTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Mood id
     */
    moodPrototypeDeleteTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeDeleteTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeDestroyByIdTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeDestroyByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeExistsTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeExistsTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeFindByIdTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeFindByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Mood id
     * @param refresh
     */
    moodPrototypeGetAccount(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries track of Mood.
     * @param id Mood id
     * @param filter
     */
    moodPrototypeGetTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     * @param data
     */
    moodPrototypeLinkTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeLinkTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Mood id
     * @param data An object of model property name/value pairs
     */
    moodPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeUnlinkTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeUnlinkTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     * @param data
     */
    moodPrototypeUpdateByIdTrack(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodPrototypeUpdateByIdTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    moodReplaceByIdPostMoodsidReplace(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodReplaceByIdPostMoodsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    moodReplaceByIdPutMoodsid(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodReplaceByIdPutMoodsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodReplaceOrCreatePutMoods(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodReplaceOrCreatePutMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    moodUpdateAll(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    moodUpsertWithWhere(params, options) {
        const fetchArgs = exports.MoodApiFetchParamCreator.moodUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * MoodApi - object-oriented interface
 */
class MoodApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    moodCount(params, options) {
        return exports.MoodApiFp.moodCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    moodCreate(params, options) {
        return exports.MoodApiFp.moodCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    moodCreateChangeStreamGetMoodsChangeStream(params, options) {
        return exports.MoodApiFp.moodCreateChangeStreamGetMoodsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    moodCreateChangeStreamPostMoodsChangeStream(params, options) {
        return exports.MoodApiFp.moodCreateChangeStreamPostMoodsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    moodDeleteById(params, options) {
        return exports.MoodApiFp.moodDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    moodExistsGetMoodsidExists(params, options) {
        return exports.MoodApiFp.moodExistsGetMoodsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    moodExistsHeadMoodsid(params, options) {
        return exports.MoodApiFp.moodExistsHeadMoodsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    moodFind(params, options) {
        return exports.MoodApiFp.moodFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    moodFindById(params, options) {
        return exports.MoodApiFp.moodFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    moodFindOne(params, options) {
        return exports.MoodApiFp.moodFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodPatchOrCreate(params, options) {
        return exports.MoodApiFp.moodPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts track of Mood.
     * @param id Mood id
     * @param where Criteria to match model instances
     */
    moodPrototypeCountTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeCountTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in track of this model.
     * @param id Mood id
     * @param data
     */
    moodPrototypeCreateTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeCreateTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all track of this model.
     * @param id Mood id
     */
    moodPrototypeDeleteTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeDeleteTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeDestroyByIdTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeDestroyByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of track relation to an item by id.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeExistsTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeExistsTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeFindByIdTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeFindByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Mood id
     * @param refresh
     */
    moodPrototypeGetAccount(params, options) {
        return exports.MoodApiFp.moodPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries track of Mood.
     * @param id Mood id
     * @param filter
     */
    moodPrototypeGetTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     * @param data
     */
    moodPrototypeLinkTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeLinkTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Mood id
     * @param data An object of model property name/value pairs
     */
    moodPrototypePatchAttributes(params, options) {
        return exports.MoodApiFp.moodPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the track relation to an item by id.
     * @param id Mood id
     * @param fk Foreign key for track
     */
    moodPrototypeUnlinkTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeUnlinkTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for track.
     * @param id Mood id
     * @param fk Foreign key for track
     * @param data
     */
    moodPrototypeUpdateByIdTrack(params, options) {
        return exports.MoodApiFp.moodPrototypeUpdateByIdTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    moodReplaceByIdPostMoodsidReplace(params, options) {
        return exports.MoodApiFp.moodReplaceByIdPostMoodsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    moodReplaceByIdPutMoodsid(params, options) {
        return exports.MoodApiFp.moodReplaceByIdPutMoodsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options) {
        return exports.MoodApiFp.moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    moodReplaceOrCreatePutMoods(params, options) {
        return exports.MoodApiFp.moodReplaceOrCreatePutMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    moodUpdateAll(params, options) {
        return exports.MoodApiFp.moodUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    moodUpsertWithWhere(params, options) {
        return exports.MoodApiFp.moodUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.MoodApi = MoodApi;
/**
 * MoodApi - factory interface
 */
const MoodApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        moodCount(params, options) {
            return exports.MoodApiFp.moodCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        moodCreate(params, options) {
            return exports.MoodApiFp.moodCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        moodCreateChangeStreamGetMoodsChangeStream(params, options) {
            return exports.MoodApiFp.moodCreateChangeStreamGetMoodsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        moodCreateChangeStreamPostMoodsChangeStream(params, options) {
            return exports.MoodApiFp.moodCreateChangeStreamPostMoodsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        moodDeleteById(params, options) {
            return exports.MoodApiFp.moodDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        moodExistsGetMoodsidExists(params, options) {
            return exports.MoodApiFp.moodExistsGetMoodsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        moodExistsHeadMoodsid(params, options) {
            return exports.MoodApiFp.moodExistsHeadMoodsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        moodFind(params, options) {
            return exports.MoodApiFp.moodFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        moodFindById(params, options) {
            return exports.MoodApiFp.moodFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        moodFindOne(params, options) {
            return exports.MoodApiFp.moodFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        moodPatchOrCreate(params, options) {
            return exports.MoodApiFp.moodPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts track of Mood.
         * @param id Mood id
         * @param where Criteria to match model instances
         */
        moodPrototypeCountTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeCountTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in track of this model.
         * @param id Mood id
         * @param data
         */
        moodPrototypeCreateTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeCreateTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all track of this model.
         * @param id Mood id
         */
        moodPrototypeDeleteTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeDeleteTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for track.
         * @param id Mood id
         * @param fk Foreign key for track
         */
        moodPrototypeDestroyByIdTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeDestroyByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of track relation to an item by id.
         * @param id Mood id
         * @param fk Foreign key for track
         */
        moodPrototypeExistsTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeExistsTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for track.
         * @param id Mood id
         * @param fk Foreign key for track
         */
        moodPrototypeFindByIdTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeFindByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Mood id
         * @param refresh
         */
        moodPrototypeGetAccount(params, options) {
            return exports.MoodApiFp.moodPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries track of Mood.
         * @param id Mood id
         * @param filter
         */
        moodPrototypeGetTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for track.
         * @param id Mood id
         * @param fk Foreign key for track
         * @param data
         */
        moodPrototypeLinkTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeLinkTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Mood id
         * @param data An object of model property name/value pairs
         */
        moodPrototypePatchAttributes(params, options) {
            return exports.MoodApiFp.moodPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the track relation to an item by id.
         * @param id Mood id
         * @param fk Foreign key for track
         */
        moodPrototypeUnlinkTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeUnlinkTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for track.
         * @param id Mood id
         * @param fk Foreign key for track
         * @param data
         */
        moodPrototypeUpdateByIdTrack(params, options) {
            return exports.MoodApiFp.moodPrototypeUpdateByIdTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        moodReplaceByIdPostMoodsidReplace(params, options) {
            return exports.MoodApiFp.moodReplaceByIdPostMoodsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        moodReplaceByIdPutMoodsid(params, options) {
            return exports.MoodApiFp.moodReplaceByIdPutMoodsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options) {
            return exports.MoodApiFp.moodReplaceOrCreatePostMoodsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        moodReplaceOrCreatePutMoods(params, options) {
            return exports.MoodApiFp.moodReplaceOrCreatePutMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        moodUpdateAll(params, options) {
            return exports.MoodApiFp.moodUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        moodUpsertWithWhere(params, options) {
            return exports.MoodApiFp.moodUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.MoodApiFactory = MoodApiFactory;
/**
 * PlaylistApi - fetch parameter creator
 */
exports.PlaylistApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    playlistCount(params, options) {
        const baseUrl = `/Playlists/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    playlistCreate(params, options) {
        const baseUrl = `/Playlists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    playlistCreateChangeStreamGetPlaylistsChangeStream(params, options) {
        const baseUrl = `/Playlists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    playlistCreateChangeStreamPostPlaylistsChangeStream(params, options) {
        const baseUrl = `/Playlists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    playlistDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistDeleteById');
        }
        const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    playlistExistsGetPlaylistsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistExistsGetPlaylistsidExists');
        }
        const baseUrl = `/Playlists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    playlistExistsHeadPlaylistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistExistsHeadPlaylistsid');
        }
        const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    playlistFind(params, options) {
        const baseUrl = `/Playlists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    playlistFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistFindById');
        }
        const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    playlistFindOne(params, options) {
        const baseUrl = `/Playlists/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistPatchOrCreate(params, options) {
        const baseUrl = `/Playlists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accounts of Playlist.
     * @param id Playlist id
     * @param where Criteria to match model instances
     */
    playlistPrototypeCountAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeCountAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts tracks of Playlist.
     * @param id Playlist id
     * @param where Criteria to match model instances
     */
    playlistPrototypeCountTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeCountTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accounts of this model.
     * @param id Playlist id
     * @param data
     */
    playlistPrototypeCreateAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeCreateAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in tracks of this model.
     * @param id Playlist id
     * @param data
     */
    playlistPrototypeCreateTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeCreateTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accounts of this model.
     * @param id Playlist id
     */
    playlistPrototypeDeleteAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeDeleteAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all tracks of this model.
     * @param id Playlist id
     */
    playlistPrototypeDeleteTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeDeleteTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeDestroyByIdAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeDestroyByIdAccounts');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeDestroyByIdAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeDestroyByIdTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeDestroyByIdTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeDestroyByIdTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of accounts relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeExistsAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeExistsAccounts');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeExistsAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of tracks relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeExistsTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeExistsTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeExistsTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeFindByIdAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeFindByIdAccounts');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeFindByIdAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeFindByIdTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeFindByIdTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeFindByIdTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accounts of Playlist.
     * @param id Playlist id
     * @param filter
     */
    playlistPrototypeGetAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeGetAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation project.
     * @param id Playlist id
     * @param refresh
     */
    playlistPrototypeGetProject(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeGetProject');
        }
        const baseUrl = `/Playlists/{id}/project`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries tracks of Playlist.
     * @param id Playlist id
     * @param filter
     */
    playlistPrototypeGetTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeGetTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     * @param data
     */
    playlistPrototypeLinkAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeLinkAccounts');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeLinkAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     * @param data
     */
    playlistPrototypeLinkTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeLinkTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeLinkTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Playlist id
     * @param data An object of model property name/value pairs
     */
    playlistPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypePatchAttributes');
        }
        const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the accounts relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeUnlinkAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeUnlinkAccounts');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeUnlinkAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the tracks relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeUnlinkTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeUnlinkTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeUnlinkTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     * @param data
     */
    playlistPrototypeUpdateByIdAccounts(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeUpdateByIdAccounts');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeUpdateByIdAccounts');
        }
        const baseUrl = `/Playlists/{id}/accounts/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     * @param data
     */
    playlistPrototypeUpdateByIdTracks(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistPrototypeUpdateByIdTracks');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling playlistPrototypeUpdateByIdTracks');
        }
        const baseUrl = `/Playlists/{id}/tracks/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    playlistReplaceByIdPostPlaylistsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistReplaceByIdPostPlaylistsidReplace');
        }
        const baseUrl = `/Playlists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    playlistReplaceByIdPutPlaylistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling playlistReplaceByIdPutPlaylistsid');
        }
        const baseUrl = `/Playlists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options) {
        const baseUrl = `/Playlists/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistReplaceOrCreatePutPlaylists(params, options) {
        const baseUrl = `/Playlists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    playlistUpdateAll(params, options) {
        const baseUrl = `/Playlists/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    playlistUpsertWithWhere(params, options) {
        const baseUrl = `/Playlists/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * PlaylistApi - functional programming interface
 */
exports.PlaylistApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    playlistCount(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    playlistCreate(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    playlistCreateChangeStreamGetPlaylistsChangeStream(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistCreateChangeStreamGetPlaylistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    playlistCreateChangeStreamPostPlaylistsChangeStream(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistCreateChangeStreamPostPlaylistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    playlistDeleteById(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    playlistExistsGetPlaylistsidExists(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistExistsGetPlaylistsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    playlistExistsHeadPlaylistsid(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistExistsHeadPlaylistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    playlistFind(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    playlistFindById(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    playlistFindOne(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistPatchOrCreate(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accounts of Playlist.
     * @param id Playlist id
     * @param where Criteria to match model instances
     */
    playlistPrototypeCountAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeCountAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts tracks of Playlist.
     * @param id Playlist id
     * @param where Criteria to match model instances
     */
    playlistPrototypeCountTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeCountTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accounts of this model.
     * @param id Playlist id
     * @param data
     */
    playlistPrototypeCreateAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeCreateAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in tracks of this model.
     * @param id Playlist id
     * @param data
     */
    playlistPrototypeCreateTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeCreateTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accounts of this model.
     * @param id Playlist id
     */
    playlistPrototypeDeleteAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeDeleteAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all tracks of this model.
     * @param id Playlist id
     */
    playlistPrototypeDeleteTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeDeleteTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeDestroyByIdAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeDestroyByIdAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeDestroyByIdTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeDestroyByIdTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of accounts relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeExistsAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeExistsAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of tracks relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeExistsTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeExistsTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeFindByIdAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeFindByIdAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeFindByIdTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeFindByIdTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accounts of Playlist.
     * @param id Playlist id
     * @param filter
     */
    playlistPrototypeGetAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeGetAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation project.
     * @param id Playlist id
     * @param refresh
     */
    playlistPrototypeGetProject(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeGetProject(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries tracks of Playlist.
     * @param id Playlist id
     * @param filter
     */
    playlistPrototypeGetTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeGetTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     * @param data
     */
    playlistPrototypeLinkAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeLinkAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     * @param data
     */
    playlistPrototypeLinkTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeLinkTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Playlist id
     * @param data An object of model property name/value pairs
     */
    playlistPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the accounts relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeUnlinkAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeUnlinkAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the tracks relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeUnlinkTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeUnlinkTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     * @param data
     */
    playlistPrototypeUpdateByIdAccounts(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeUpdateByIdAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     * @param data
     */
    playlistPrototypeUpdateByIdTracks(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistPrototypeUpdateByIdTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    playlistReplaceByIdPostPlaylistsidReplace(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistReplaceByIdPostPlaylistsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    playlistReplaceByIdPutPlaylistsid(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistReplaceByIdPutPlaylistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistReplaceOrCreatePutPlaylists(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistReplaceOrCreatePutPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    playlistUpdateAll(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    playlistUpsertWithWhere(params, options) {
        const fetchArgs = exports.PlaylistApiFetchParamCreator.playlistUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * PlaylistApi - object-oriented interface
 */
class PlaylistApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    playlistCount(params, options) {
        return exports.PlaylistApiFp.playlistCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    playlistCreate(params, options) {
        return exports.PlaylistApiFp.playlistCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    playlistCreateChangeStreamGetPlaylistsChangeStream(params, options) {
        return exports.PlaylistApiFp.playlistCreateChangeStreamGetPlaylistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    playlistCreateChangeStreamPostPlaylistsChangeStream(params, options) {
        return exports.PlaylistApiFp.playlistCreateChangeStreamPostPlaylistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    playlistDeleteById(params, options) {
        return exports.PlaylistApiFp.playlistDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    playlistExistsGetPlaylistsidExists(params, options) {
        return exports.PlaylistApiFp.playlistExistsGetPlaylistsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    playlistExistsHeadPlaylistsid(params, options) {
        return exports.PlaylistApiFp.playlistExistsHeadPlaylistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    playlistFind(params, options) {
        return exports.PlaylistApiFp.playlistFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    playlistFindById(params, options) {
        return exports.PlaylistApiFp.playlistFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    playlistFindOne(params, options) {
        return exports.PlaylistApiFp.playlistFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistPatchOrCreate(params, options) {
        return exports.PlaylistApiFp.playlistPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accounts of Playlist.
     * @param id Playlist id
     * @param where Criteria to match model instances
     */
    playlistPrototypeCountAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeCountAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts tracks of Playlist.
     * @param id Playlist id
     * @param where Criteria to match model instances
     */
    playlistPrototypeCountTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeCountTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accounts of this model.
     * @param id Playlist id
     * @param data
     */
    playlistPrototypeCreateAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeCreateAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in tracks of this model.
     * @param id Playlist id
     * @param data
     */
    playlistPrototypeCreateTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeCreateTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accounts of this model.
     * @param id Playlist id
     */
    playlistPrototypeDeleteAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeDeleteAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all tracks of this model.
     * @param id Playlist id
     */
    playlistPrototypeDeleteTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeDeleteTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeDestroyByIdAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeDestroyByIdAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeDestroyByIdTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeDestroyByIdTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of accounts relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeExistsAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeExistsAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of tracks relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeExistsTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeExistsTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeFindByIdAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeFindByIdAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeFindByIdTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeFindByIdTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accounts of Playlist.
     * @param id Playlist id
     * @param filter
     */
    playlistPrototypeGetAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeGetAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation project.
     * @param id Playlist id
     * @param refresh
     */
    playlistPrototypeGetProject(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeGetProject(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries tracks of Playlist.
     * @param id Playlist id
     * @param filter
     */
    playlistPrototypeGetTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeGetTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     * @param data
     */
    playlistPrototypeLinkAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeLinkAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     * @param data
     */
    playlistPrototypeLinkTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeLinkTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Playlist id
     * @param data An object of model property name/value pairs
     */
    playlistPrototypePatchAttributes(params, options) {
        return exports.PlaylistApiFp.playlistPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the accounts relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     */
    playlistPrototypeUnlinkAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeUnlinkAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the tracks relation to an item by id.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     */
    playlistPrototypeUnlinkTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeUnlinkTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accounts.
     * @param id Playlist id
     * @param fk Foreign key for accounts
     * @param data
     */
    playlistPrototypeUpdateByIdAccounts(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeUpdateByIdAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for tracks.
     * @param id Playlist id
     * @param fk Foreign key for tracks
     * @param data
     */
    playlistPrototypeUpdateByIdTracks(params, options) {
        return exports.PlaylistApiFp.playlistPrototypeUpdateByIdTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    playlistReplaceByIdPostPlaylistsidReplace(params, options) {
        return exports.PlaylistApiFp.playlistReplaceByIdPostPlaylistsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    playlistReplaceByIdPutPlaylistsid(params, options) {
        return exports.PlaylistApiFp.playlistReplaceByIdPutPlaylistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options) {
        return exports.PlaylistApiFp.playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    playlistReplaceOrCreatePutPlaylists(params, options) {
        return exports.PlaylistApiFp.playlistReplaceOrCreatePutPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    playlistUpdateAll(params, options) {
        return exports.PlaylistApiFp.playlistUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    playlistUpsertWithWhere(params, options) {
        return exports.PlaylistApiFp.playlistUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.PlaylistApi = PlaylistApi;
/**
 * PlaylistApi - factory interface
 */
const PlaylistApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        playlistCount(params, options) {
            return exports.PlaylistApiFp.playlistCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        playlistCreate(params, options) {
            return exports.PlaylistApiFp.playlistCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        playlistCreateChangeStreamGetPlaylistsChangeStream(params, options) {
            return exports.PlaylistApiFp.playlistCreateChangeStreamGetPlaylistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        playlistCreateChangeStreamPostPlaylistsChangeStream(params, options) {
            return exports.PlaylistApiFp.playlistCreateChangeStreamPostPlaylistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        playlistDeleteById(params, options) {
            return exports.PlaylistApiFp.playlistDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        playlistExistsGetPlaylistsidExists(params, options) {
            return exports.PlaylistApiFp.playlistExistsGetPlaylistsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        playlistExistsHeadPlaylistsid(params, options) {
            return exports.PlaylistApiFp.playlistExistsHeadPlaylistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        playlistFind(params, options) {
            return exports.PlaylistApiFp.playlistFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        playlistFindById(params, options) {
            return exports.PlaylistApiFp.playlistFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        playlistFindOne(params, options) {
            return exports.PlaylistApiFp.playlistFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        playlistPatchOrCreate(params, options) {
            return exports.PlaylistApiFp.playlistPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accounts of Playlist.
         * @param id Playlist id
         * @param where Criteria to match model instances
         */
        playlistPrototypeCountAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeCountAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts tracks of Playlist.
         * @param id Playlist id
         * @param where Criteria to match model instances
         */
        playlistPrototypeCountTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeCountTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accounts of this model.
         * @param id Playlist id
         * @param data
         */
        playlistPrototypeCreateAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeCreateAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in tracks of this model.
         * @param id Playlist id
         * @param data
         */
        playlistPrototypeCreateTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeCreateTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accounts of this model.
         * @param id Playlist id
         */
        playlistPrototypeDeleteAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeDeleteAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all tracks of this model.
         * @param id Playlist id
         */
        playlistPrototypeDeleteTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeDeleteTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accounts.
         * @param id Playlist id
         * @param fk Foreign key for accounts
         */
        playlistPrototypeDestroyByIdAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeDestroyByIdAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for tracks.
         * @param id Playlist id
         * @param fk Foreign key for tracks
         */
        playlistPrototypeDestroyByIdTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeDestroyByIdTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of accounts relation to an item by id.
         * @param id Playlist id
         * @param fk Foreign key for accounts
         */
        playlistPrototypeExistsAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeExistsAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of tracks relation to an item by id.
         * @param id Playlist id
         * @param fk Foreign key for tracks
         */
        playlistPrototypeExistsTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeExistsTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accounts.
         * @param id Playlist id
         * @param fk Foreign key for accounts
         */
        playlistPrototypeFindByIdAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeFindByIdAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for tracks.
         * @param id Playlist id
         * @param fk Foreign key for tracks
         */
        playlistPrototypeFindByIdTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeFindByIdTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accounts of Playlist.
         * @param id Playlist id
         * @param filter
         */
        playlistPrototypeGetAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeGetAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation project.
         * @param id Playlist id
         * @param refresh
         */
        playlistPrototypeGetProject(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeGetProject(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries tracks of Playlist.
         * @param id Playlist id
         * @param filter
         */
        playlistPrototypeGetTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeGetTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for accounts.
         * @param id Playlist id
         * @param fk Foreign key for accounts
         * @param data
         */
        playlistPrototypeLinkAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeLinkAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for tracks.
         * @param id Playlist id
         * @param fk Foreign key for tracks
         * @param data
         */
        playlistPrototypeLinkTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeLinkTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Playlist id
         * @param data An object of model property name/value pairs
         */
        playlistPrototypePatchAttributes(params, options) {
            return exports.PlaylistApiFp.playlistPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the accounts relation to an item by id.
         * @param id Playlist id
         * @param fk Foreign key for accounts
         */
        playlistPrototypeUnlinkAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeUnlinkAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the tracks relation to an item by id.
         * @param id Playlist id
         * @param fk Foreign key for tracks
         */
        playlistPrototypeUnlinkTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeUnlinkTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accounts.
         * @param id Playlist id
         * @param fk Foreign key for accounts
         * @param data
         */
        playlistPrototypeUpdateByIdAccounts(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeUpdateByIdAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for tracks.
         * @param id Playlist id
         * @param fk Foreign key for tracks
         * @param data
         */
        playlistPrototypeUpdateByIdTracks(params, options) {
            return exports.PlaylistApiFp.playlistPrototypeUpdateByIdTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        playlistReplaceByIdPostPlaylistsidReplace(params, options) {
            return exports.PlaylistApiFp.playlistReplaceByIdPostPlaylistsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        playlistReplaceByIdPutPlaylistsid(params, options) {
            return exports.PlaylistApiFp.playlistReplaceByIdPutPlaylistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options) {
            return exports.PlaylistApiFp.playlistReplaceOrCreatePostPlaylistsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        playlistReplaceOrCreatePutPlaylists(params, options) {
            return exports.PlaylistApiFp.playlistReplaceOrCreatePutPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        playlistUpdateAll(params, options) {
            return exports.PlaylistApiFp.playlistUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        playlistUpsertWithWhere(params, options) {
            return exports.PlaylistApiFp.playlistUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.PlaylistApiFactory = PlaylistApiFactory;
/**
 * PriceApi - fetch parameter creator
 */
exports.PriceApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    priceCount(params, options) {
        const baseUrl = `/Prices/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    priceCreate(params, options) {
        const baseUrl = `/Prices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    priceCreateChangeStreamGetPricesChangeStream(params, options) {
        const baseUrl = `/Prices/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    priceCreateChangeStreamPostPricesChangeStream(params, options) {
        const baseUrl = `/Prices/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    priceDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling priceDeleteById');
        }
        const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    priceExistsGetPricesidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling priceExistsGetPricesidExists');
        }
        const baseUrl = `/Prices/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    priceExistsHeadPricesid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling priceExistsHeadPricesid');
        }
        const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    priceFind(params, options) {
        const baseUrl = `/Prices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    priceFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling priceFindById');
        }
        const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    priceFindOne(params, options) {
        const baseUrl = `/Prices/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pricePatchOrCreate(params, options) {
        const baseUrl = `/Prices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Price id
     * @param refresh
     */
    pricePrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling pricePrototypeGetAccount');
        }
        const baseUrl = `/Prices/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Price id
     * @param data An object of model property name/value pairs
     */
    pricePrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling pricePrototypePatchAttributes');
        }
        const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    priceReplaceByIdPostPricesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling priceReplaceByIdPostPricesidReplace');
        }
        const baseUrl = `/Prices/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    priceReplaceByIdPutPricesid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling priceReplaceByIdPutPricesid');
        }
        const baseUrl = `/Prices/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    priceReplaceOrCreatePostPricesReplaceOrCreate(params, options) {
        const baseUrl = `/Prices/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    priceReplaceOrCreatePutPrices(params, options) {
        const baseUrl = `/Prices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    priceUpdateAll(params, options) {
        const baseUrl = `/Prices/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    priceUpsertWithWhere(params, options) {
        const baseUrl = `/Prices/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * PriceApi - functional programming interface
 */
exports.PriceApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    priceCount(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    priceCreate(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    priceCreateChangeStreamGetPricesChangeStream(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceCreateChangeStreamGetPricesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    priceCreateChangeStreamPostPricesChangeStream(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceCreateChangeStreamPostPricesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    priceDeleteById(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    priceExistsGetPricesidExists(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceExistsGetPricesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    priceExistsHeadPricesid(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceExistsHeadPricesid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    priceFind(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    priceFindById(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    priceFindOne(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pricePatchOrCreate(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.pricePatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Price id
     * @param refresh
     */
    pricePrototypeGetAccount(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.pricePrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Price id
     * @param data An object of model property name/value pairs
     */
    pricePrototypePatchAttributes(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.pricePrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    priceReplaceByIdPostPricesidReplace(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceReplaceByIdPostPricesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    priceReplaceByIdPutPricesid(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceReplaceByIdPutPricesid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    priceReplaceOrCreatePostPricesReplaceOrCreate(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceReplaceOrCreatePostPricesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    priceReplaceOrCreatePutPrices(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceReplaceOrCreatePutPrices(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    priceUpdateAll(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    priceUpsertWithWhere(params, options) {
        const fetchArgs = exports.PriceApiFetchParamCreator.priceUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * PriceApi - object-oriented interface
 */
class PriceApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    priceCount(params, options) {
        return exports.PriceApiFp.priceCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    priceCreate(params, options) {
        return exports.PriceApiFp.priceCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    priceCreateChangeStreamGetPricesChangeStream(params, options) {
        return exports.PriceApiFp.priceCreateChangeStreamGetPricesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    priceCreateChangeStreamPostPricesChangeStream(params, options) {
        return exports.PriceApiFp.priceCreateChangeStreamPostPricesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    priceDeleteById(params, options) {
        return exports.PriceApiFp.priceDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    priceExistsGetPricesidExists(params, options) {
        return exports.PriceApiFp.priceExistsGetPricesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    priceExistsHeadPricesid(params, options) {
        return exports.PriceApiFp.priceExistsHeadPricesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    priceFind(params, options) {
        return exports.PriceApiFp.priceFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    priceFindById(params, options) {
        return exports.PriceApiFp.priceFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    priceFindOne(params, options) {
        return exports.PriceApiFp.priceFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pricePatchOrCreate(params, options) {
        return exports.PriceApiFp.pricePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Price id
     * @param refresh
     */
    pricePrototypeGetAccount(params, options) {
        return exports.PriceApiFp.pricePrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Price id
     * @param data An object of model property name/value pairs
     */
    pricePrototypePatchAttributes(params, options) {
        return exports.PriceApiFp.pricePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    priceReplaceByIdPostPricesidReplace(params, options) {
        return exports.PriceApiFp.priceReplaceByIdPostPricesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    priceReplaceByIdPutPricesid(params, options) {
        return exports.PriceApiFp.priceReplaceByIdPutPricesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    priceReplaceOrCreatePostPricesReplaceOrCreate(params, options) {
        return exports.PriceApiFp.priceReplaceOrCreatePostPricesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    priceReplaceOrCreatePutPrices(params, options) {
        return exports.PriceApiFp.priceReplaceOrCreatePutPrices(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    priceUpdateAll(params, options) {
        return exports.PriceApiFp.priceUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    priceUpsertWithWhere(params, options) {
        return exports.PriceApiFp.priceUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.PriceApi = PriceApi;
/**
 * PriceApi - factory interface
 */
const PriceApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        priceCount(params, options) {
            return exports.PriceApiFp.priceCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        priceCreate(params, options) {
            return exports.PriceApiFp.priceCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        priceCreateChangeStreamGetPricesChangeStream(params, options) {
            return exports.PriceApiFp.priceCreateChangeStreamGetPricesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        priceCreateChangeStreamPostPricesChangeStream(params, options) {
            return exports.PriceApiFp.priceCreateChangeStreamPostPricesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        priceDeleteById(params, options) {
            return exports.PriceApiFp.priceDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        priceExistsGetPricesidExists(params, options) {
            return exports.PriceApiFp.priceExistsGetPricesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        priceExistsHeadPricesid(params, options) {
            return exports.PriceApiFp.priceExistsHeadPricesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        priceFind(params, options) {
            return exports.PriceApiFp.priceFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        priceFindById(params, options) {
            return exports.PriceApiFp.priceFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        priceFindOne(params, options) {
            return exports.PriceApiFp.priceFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        pricePatchOrCreate(params, options) {
            return exports.PriceApiFp.pricePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Price id
         * @param refresh
         */
        pricePrototypeGetAccount(params, options) {
            return exports.PriceApiFp.pricePrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Price id
         * @param data An object of model property name/value pairs
         */
        pricePrototypePatchAttributes(params, options) {
            return exports.PriceApiFp.pricePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        priceReplaceByIdPostPricesidReplace(params, options) {
            return exports.PriceApiFp.priceReplaceByIdPostPricesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        priceReplaceByIdPutPricesid(params, options) {
            return exports.PriceApiFp.priceReplaceByIdPutPricesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        priceReplaceOrCreatePostPricesReplaceOrCreate(params, options) {
            return exports.PriceApiFp.priceReplaceOrCreatePostPricesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        priceReplaceOrCreatePutPrices(params, options) {
            return exports.PriceApiFp.priceReplaceOrCreatePutPrices(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        priceUpdateAll(params, options) {
            return exports.PriceApiFp.priceUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        priceUpsertWithWhere(params, options) {
            return exports.PriceApiFp.priceUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.PriceApiFactory = PriceApiFactory;
/**
 * ProjectApi - fetch parameter creator
 */
exports.ProjectApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    projectCount(params, options) {
        const baseUrl = `/Projects/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    projectCreate(params, options) {
        const baseUrl = `/Projects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    projectCreateChangeStreamGetProjectsChangeStream(params, options) {
        const baseUrl = `/Projects/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    projectCreateChangeStreamPostProjectsChangeStream(params, options) {
        const baseUrl = `/Projects/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    projectDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectDeleteById');
        }
        const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    projectExistsGetProjectsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectExistsGetProjectsidExists');
        }
        const baseUrl = `/Projects/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    projectExistsHeadProjectsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectExistsHeadProjectsid');
        }
        const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    projectFind(params, options) {
        const baseUrl = `/Projects`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    projectFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectFindById');
        }
        const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    projectFindOne(params, options) {
        const baseUrl = `/Projects/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectPatchOrCreate(params, options) {
        const baseUrl = `/Projects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts onwer of Project.
     * @param id Project id
     * @param where Criteria to match model instances
     */
    projectPrototypeCountOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeCountOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts playlists of Project.
     * @param id Project id
     * @param where Criteria to match model instances
     */
    projectPrototypeCountPlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeCountPlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in onwer of this model.
     * @param id Project id
     * @param data
     */
    projectPrototypeCreateOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeCreateOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in playlists of this model.
     * @param id Project id
     * @param data
     */
    projectPrototypeCreatePlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeCreatePlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all onwer of this model.
     * @param id Project id
     */
    projectPrototypeDeleteOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeDeleteOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all playlists of this model.
     * @param id Project id
     */
    projectPrototypeDeletePlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeDeletePlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeDestroyByIdOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeDestroyByIdOnwer');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeDestroyByIdOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     */
    projectPrototypeDestroyByIdPlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeDestroyByIdPlaylists');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeDestroyByIdPlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of onwer relation to an item by id.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeExistsOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeExistsOnwer');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeExistsOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeFindByIdOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeFindByIdOnwer');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeFindByIdOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     */
    projectPrototypeFindByIdPlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeFindByIdPlaylists');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeFindByIdPlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries onwer of Project.
     * @param id Project id
     * @param filter
     */
    projectPrototypeGetOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeGetOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries playlists of Project.
     * @param id Project id
     * @param filter
     */
    projectPrototypeGetPlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeGetPlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     * @param data
     */
    projectPrototypeLinkOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeLinkOnwer');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeLinkOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Project id
     * @param data An object of model property name/value pairs
     */
    projectPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypePatchAttributes');
        }
        const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the onwer relation to an item by id.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeUnlinkOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeUnlinkOnwer');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeUnlinkOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     * @param data
     */
    projectPrototypeUpdateByIdOnwer(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeUpdateByIdOnwer');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeUpdateByIdOnwer');
        }
        const baseUrl = `/Projects/{id}/onwer/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     * @param data
     */
    projectPrototypeUpdateByIdPlaylists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectPrototypeUpdateByIdPlaylists');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling projectPrototypeUpdateByIdPlaylists');
        }
        const baseUrl = `/Projects/{id}/playlists/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    projectReplaceByIdPostProjectsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectReplaceByIdPostProjectsidReplace');
        }
        const baseUrl = `/Projects/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    projectReplaceByIdPutProjectsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling projectReplaceByIdPutProjectsid');
        }
        const baseUrl = `/Projects/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options) {
        const baseUrl = `/Projects/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectReplaceOrCreatePutProjects(params, options) {
        const baseUrl = `/Projects`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    projectUpdateAll(params, options) {
        const baseUrl = `/Projects/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    projectUpsertWithWhere(params, options) {
        const baseUrl = `/Projects/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ProjectApi - functional programming interface
 */
exports.ProjectApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    projectCount(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    projectCreate(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    projectCreateChangeStreamGetProjectsChangeStream(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectCreateChangeStreamGetProjectsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    projectCreateChangeStreamPostProjectsChangeStream(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectCreateChangeStreamPostProjectsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    projectDeleteById(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    projectExistsGetProjectsidExists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectExistsGetProjectsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    projectExistsHeadProjectsid(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectExistsHeadProjectsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    projectFind(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    projectFindById(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    projectFindOne(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectPatchOrCreate(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts onwer of Project.
     * @param id Project id
     * @param where Criteria to match model instances
     */
    projectPrototypeCountOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeCountOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts playlists of Project.
     * @param id Project id
     * @param where Criteria to match model instances
     */
    projectPrototypeCountPlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeCountPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in onwer of this model.
     * @param id Project id
     * @param data
     */
    projectPrototypeCreateOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeCreateOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in playlists of this model.
     * @param id Project id
     * @param data
     */
    projectPrototypeCreatePlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeCreatePlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all onwer of this model.
     * @param id Project id
     */
    projectPrototypeDeleteOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeDeleteOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all playlists of this model.
     * @param id Project id
     */
    projectPrototypeDeletePlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeDeletePlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeDestroyByIdOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeDestroyByIdOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     */
    projectPrototypeDestroyByIdPlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeDestroyByIdPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of onwer relation to an item by id.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeExistsOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeExistsOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeFindByIdOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeFindByIdOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     */
    projectPrototypeFindByIdPlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeFindByIdPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries onwer of Project.
     * @param id Project id
     * @param filter
     */
    projectPrototypeGetOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeGetOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries playlists of Project.
     * @param id Project id
     * @param filter
     */
    projectPrototypeGetPlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeGetPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     * @param data
     */
    projectPrototypeLinkOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeLinkOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Project id
     * @param data An object of model property name/value pairs
     */
    projectPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the onwer relation to an item by id.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeUnlinkOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeUnlinkOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     * @param data
     */
    projectPrototypeUpdateByIdOnwer(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeUpdateByIdOnwer(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     * @param data
     */
    projectPrototypeUpdateByIdPlaylists(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectPrototypeUpdateByIdPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    projectReplaceByIdPostProjectsidReplace(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectReplaceByIdPostProjectsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    projectReplaceByIdPutProjectsid(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectReplaceByIdPutProjectsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectReplaceOrCreatePutProjects(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectReplaceOrCreatePutProjects(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    projectUpdateAll(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    projectUpsertWithWhere(params, options) {
        const fetchArgs = exports.ProjectApiFetchParamCreator.projectUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ProjectApi - object-oriented interface
 */
class ProjectApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    projectCount(params, options) {
        return exports.ProjectApiFp.projectCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    projectCreate(params, options) {
        return exports.ProjectApiFp.projectCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    projectCreateChangeStreamGetProjectsChangeStream(params, options) {
        return exports.ProjectApiFp.projectCreateChangeStreamGetProjectsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    projectCreateChangeStreamPostProjectsChangeStream(params, options) {
        return exports.ProjectApiFp.projectCreateChangeStreamPostProjectsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    projectDeleteById(params, options) {
        return exports.ProjectApiFp.projectDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    projectExistsGetProjectsidExists(params, options) {
        return exports.ProjectApiFp.projectExistsGetProjectsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    projectExistsHeadProjectsid(params, options) {
        return exports.ProjectApiFp.projectExistsHeadProjectsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    projectFind(params, options) {
        return exports.ProjectApiFp.projectFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    projectFindById(params, options) {
        return exports.ProjectApiFp.projectFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    projectFindOne(params, options) {
        return exports.ProjectApiFp.projectFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectPatchOrCreate(params, options) {
        return exports.ProjectApiFp.projectPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts onwer of Project.
     * @param id Project id
     * @param where Criteria to match model instances
     */
    projectPrototypeCountOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeCountOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts playlists of Project.
     * @param id Project id
     * @param where Criteria to match model instances
     */
    projectPrototypeCountPlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeCountPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in onwer of this model.
     * @param id Project id
     * @param data
     */
    projectPrototypeCreateOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeCreateOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in playlists of this model.
     * @param id Project id
     * @param data
     */
    projectPrototypeCreatePlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeCreatePlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all onwer of this model.
     * @param id Project id
     */
    projectPrototypeDeleteOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeDeleteOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all playlists of this model.
     * @param id Project id
     */
    projectPrototypeDeletePlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeDeletePlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeDestroyByIdOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeDestroyByIdOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     */
    projectPrototypeDestroyByIdPlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeDestroyByIdPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of onwer relation to an item by id.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeExistsOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeExistsOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeFindByIdOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeFindByIdOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     */
    projectPrototypeFindByIdPlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeFindByIdPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries onwer of Project.
     * @param id Project id
     * @param filter
     */
    projectPrototypeGetOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeGetOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries playlists of Project.
     * @param id Project id
     * @param filter
     */
    projectPrototypeGetPlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeGetPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     * @param data
     */
    projectPrototypeLinkOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeLinkOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Project id
     * @param data An object of model property name/value pairs
     */
    projectPrototypePatchAttributes(params, options) {
        return exports.ProjectApiFp.projectPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the onwer relation to an item by id.
     * @param id Project id
     * @param fk Foreign key for onwer
     */
    projectPrototypeUnlinkOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeUnlinkOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for onwer.
     * @param id Project id
     * @param fk Foreign key for onwer
     * @param data
     */
    projectPrototypeUpdateByIdOnwer(params, options) {
        return exports.ProjectApiFp.projectPrototypeUpdateByIdOnwer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for playlists.
     * @param id Project id
     * @param fk Foreign key for playlists
     * @param data
     */
    projectPrototypeUpdateByIdPlaylists(params, options) {
        return exports.ProjectApiFp.projectPrototypeUpdateByIdPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    projectReplaceByIdPostProjectsidReplace(params, options) {
        return exports.ProjectApiFp.projectReplaceByIdPostProjectsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    projectReplaceByIdPutProjectsid(params, options) {
        return exports.ProjectApiFp.projectReplaceByIdPutProjectsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options) {
        return exports.ProjectApiFp.projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    projectReplaceOrCreatePutProjects(params, options) {
        return exports.ProjectApiFp.projectReplaceOrCreatePutProjects(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    projectUpdateAll(params, options) {
        return exports.ProjectApiFp.projectUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    projectUpsertWithWhere(params, options) {
        return exports.ProjectApiFp.projectUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ProjectApi = ProjectApi;
/**
 * ProjectApi - factory interface
 */
const ProjectApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        projectCount(params, options) {
            return exports.ProjectApiFp.projectCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        projectCreate(params, options) {
            return exports.ProjectApiFp.projectCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        projectCreateChangeStreamGetProjectsChangeStream(params, options) {
            return exports.ProjectApiFp.projectCreateChangeStreamGetProjectsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        projectCreateChangeStreamPostProjectsChangeStream(params, options) {
            return exports.ProjectApiFp.projectCreateChangeStreamPostProjectsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        projectDeleteById(params, options) {
            return exports.ProjectApiFp.projectDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        projectExistsGetProjectsidExists(params, options) {
            return exports.ProjectApiFp.projectExistsGetProjectsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        projectExistsHeadProjectsid(params, options) {
            return exports.ProjectApiFp.projectExistsHeadProjectsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        projectFind(params, options) {
            return exports.ProjectApiFp.projectFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        projectFindById(params, options) {
            return exports.ProjectApiFp.projectFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        projectFindOne(params, options) {
            return exports.ProjectApiFp.projectFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        projectPatchOrCreate(params, options) {
            return exports.ProjectApiFp.projectPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts onwer of Project.
         * @param id Project id
         * @param where Criteria to match model instances
         */
        projectPrototypeCountOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeCountOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts playlists of Project.
         * @param id Project id
         * @param where Criteria to match model instances
         */
        projectPrototypeCountPlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeCountPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in onwer of this model.
         * @param id Project id
         * @param data
         */
        projectPrototypeCreateOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeCreateOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in playlists of this model.
         * @param id Project id
         * @param data
         */
        projectPrototypeCreatePlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeCreatePlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all onwer of this model.
         * @param id Project id
         */
        projectPrototypeDeleteOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeDeleteOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all playlists of this model.
         * @param id Project id
         */
        projectPrototypeDeletePlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeDeletePlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for onwer.
         * @param id Project id
         * @param fk Foreign key for onwer
         */
        projectPrototypeDestroyByIdOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeDestroyByIdOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for playlists.
         * @param id Project id
         * @param fk Foreign key for playlists
         */
        projectPrototypeDestroyByIdPlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeDestroyByIdPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of onwer relation to an item by id.
         * @param id Project id
         * @param fk Foreign key for onwer
         */
        projectPrototypeExistsOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeExistsOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for onwer.
         * @param id Project id
         * @param fk Foreign key for onwer
         */
        projectPrototypeFindByIdOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeFindByIdOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for playlists.
         * @param id Project id
         * @param fk Foreign key for playlists
         */
        projectPrototypeFindByIdPlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeFindByIdPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries onwer of Project.
         * @param id Project id
         * @param filter
         */
        projectPrototypeGetOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeGetOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries playlists of Project.
         * @param id Project id
         * @param filter
         */
        projectPrototypeGetPlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeGetPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for onwer.
         * @param id Project id
         * @param fk Foreign key for onwer
         * @param data
         */
        projectPrototypeLinkOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeLinkOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Project id
         * @param data An object of model property name/value pairs
         */
        projectPrototypePatchAttributes(params, options) {
            return exports.ProjectApiFp.projectPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the onwer relation to an item by id.
         * @param id Project id
         * @param fk Foreign key for onwer
         */
        projectPrototypeUnlinkOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeUnlinkOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for onwer.
         * @param id Project id
         * @param fk Foreign key for onwer
         * @param data
         */
        projectPrototypeUpdateByIdOnwer(params, options) {
            return exports.ProjectApiFp.projectPrototypeUpdateByIdOnwer(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for playlists.
         * @param id Project id
         * @param fk Foreign key for playlists
         * @param data
         */
        projectPrototypeUpdateByIdPlaylists(params, options) {
            return exports.ProjectApiFp.projectPrototypeUpdateByIdPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        projectReplaceByIdPostProjectsidReplace(params, options) {
            return exports.ProjectApiFp.projectReplaceByIdPostProjectsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        projectReplaceByIdPutProjectsid(params, options) {
            return exports.ProjectApiFp.projectReplaceByIdPutProjectsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options) {
            return exports.ProjectApiFp.projectReplaceOrCreatePostProjectsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        projectReplaceOrCreatePutProjects(params, options) {
            return exports.ProjectApiFp.projectReplaceOrCreatePutProjects(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        projectUpdateAll(params, options) {
            return exports.ProjectApiFp.projectUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        projectUpsertWithWhere(params, options) {
            return exports.ProjectApiFp.projectUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ProjectApiFactory = ProjectApiFactory;
/**
 * SubscriptionApi - fetch parameter creator
 */
exports.SubscriptionApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    subscriptionCount(params, options) {
        const baseUrl = `/Subscriptions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    subscriptionCreate(params, options) {
        const baseUrl = `/Subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options) {
        const baseUrl = `/Subscriptions/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options) {
        const baseUrl = `/Subscriptions/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    subscriptionDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionDeleteById');
        }
        const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    subscriptionExistsGetSubscriptionsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionExistsGetSubscriptionsidExists');
        }
        const baseUrl = `/Subscriptions/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    subscriptionExistsHeadSubscriptionsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionExistsHeadSubscriptionsid');
        }
        const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    subscriptionFind(params, options) {
        const baseUrl = `/Subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    subscriptionFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionFindById');
        }
        const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    subscriptionFindOne(params, options) {
        const baseUrl = `/Subscriptions/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionPatchOrCreate(params, options) {
        const baseUrl = `/Subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts account of Subscription.
     * @param id Subscription id
     * @param where Criteria to match model instances
     */
    subscriptionPrototypeCountAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeCountAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in account of this model.
     * @param id Subscription id
     * @param data
     */
    subscriptionPrototypeCreateAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeCreateAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all account of this model.
     * @param id Subscription id
     */
    subscriptionPrototypeDeleteAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeDeleteAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeDestroyByIdAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeDestroyByIdAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling subscriptionPrototypeDestroyByIdAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of account relation to an item by id.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeExistsAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeExistsAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling subscriptionPrototypeExistsAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeFindByIdAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeFindByIdAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling subscriptionPrototypeFindByIdAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries account of Subscription.
     * @param id Subscription id
     * @param filter
     */
    subscriptionPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeGetAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation creater.
     * @param id Subscription id
     * @param refresh
     */
    subscriptionPrototypeGetCreater(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeGetCreater');
        }
        const baseUrl = `/Subscriptions/{id}/creater`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     * @param data
     */
    subscriptionPrototypeLinkAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeLinkAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling subscriptionPrototypeLinkAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Subscription id
     * @param data An object of model property name/value pairs
     */
    subscriptionPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypePatchAttributes');
        }
        const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the account relation to an item by id.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeUnlinkAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeUnlinkAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling subscriptionPrototypeUnlinkAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     * @param data
     */
    subscriptionPrototypeUpdateByIdAccount(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionPrototypeUpdateByIdAccount');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling subscriptionPrototypeUpdateByIdAccount');
        }
        const baseUrl = `/Subscriptions/{id}/account/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    subscriptionReplaceByIdPostSubscriptionsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionReplaceByIdPostSubscriptionsidReplace');
        }
        const baseUrl = `/Subscriptions/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    subscriptionReplaceByIdPutSubscriptionsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling subscriptionReplaceByIdPutSubscriptionsid');
        }
        const baseUrl = `/Subscriptions/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options) {
        const baseUrl = `/Subscriptions/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionReplaceOrCreatePutSubscriptions(params, options) {
        const baseUrl = `/Subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    subscriptionUpdateAll(params, options) {
        const baseUrl = `/Subscriptions/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    subscriptionUpsertWithWhere(params, options) {
        const baseUrl = `/Subscriptions/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * SubscriptionApi - functional programming interface
 */
exports.SubscriptionApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    subscriptionCount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    subscriptionCreate(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    subscriptionDeleteById(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    subscriptionExistsGetSubscriptionsidExists(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionExistsGetSubscriptionsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    subscriptionExistsHeadSubscriptionsid(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionExistsHeadSubscriptionsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    subscriptionFind(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    subscriptionFindById(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    subscriptionFindOne(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionPatchOrCreate(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts account of Subscription.
     * @param id Subscription id
     * @param where Criteria to match model instances
     */
    subscriptionPrototypeCountAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeCountAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in account of this model.
     * @param id Subscription id
     * @param data
     */
    subscriptionPrototypeCreateAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeCreateAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all account of this model.
     * @param id Subscription id
     */
    subscriptionPrototypeDeleteAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeDeleteAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeDestroyByIdAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeDestroyByIdAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of account relation to an item by id.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeExistsAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeExistsAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeFindByIdAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeFindByIdAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries account of Subscription.
     * @param id Subscription id
     * @param filter
     */
    subscriptionPrototypeGetAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation creater.
     * @param id Subscription id
     * @param refresh
     */
    subscriptionPrototypeGetCreater(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeGetCreater(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     * @param data
     */
    subscriptionPrototypeLinkAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeLinkAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Subscription id
     * @param data An object of model property name/value pairs
     */
    subscriptionPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the account relation to an item by id.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeUnlinkAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeUnlinkAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     * @param data
     */
    subscriptionPrototypeUpdateByIdAccount(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionPrototypeUpdateByIdAccount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    subscriptionReplaceByIdPostSubscriptionsidReplace(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionReplaceByIdPostSubscriptionsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    subscriptionReplaceByIdPutSubscriptionsid(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionReplaceByIdPutSubscriptionsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionReplaceOrCreatePutSubscriptions(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionReplaceOrCreatePutSubscriptions(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    subscriptionUpdateAll(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    subscriptionUpsertWithWhere(params, options) {
        const fetchArgs = exports.SubscriptionApiFetchParamCreator.subscriptionUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * SubscriptionApi - object-oriented interface
 */
class SubscriptionApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    subscriptionCount(params, options) {
        return exports.SubscriptionApiFp.subscriptionCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    subscriptionCreate(params, options) {
        return exports.SubscriptionApiFp.subscriptionCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options) {
        return exports.SubscriptionApiFp.subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options) {
        return exports.SubscriptionApiFp.subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    subscriptionDeleteById(params, options) {
        return exports.SubscriptionApiFp.subscriptionDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    subscriptionExistsGetSubscriptionsidExists(params, options) {
        return exports.SubscriptionApiFp.subscriptionExistsGetSubscriptionsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    subscriptionExistsHeadSubscriptionsid(params, options) {
        return exports.SubscriptionApiFp.subscriptionExistsHeadSubscriptionsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    subscriptionFind(params, options) {
        return exports.SubscriptionApiFp.subscriptionFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    subscriptionFindById(params, options) {
        return exports.SubscriptionApiFp.subscriptionFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    subscriptionFindOne(params, options) {
        return exports.SubscriptionApiFp.subscriptionFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionPatchOrCreate(params, options) {
        return exports.SubscriptionApiFp.subscriptionPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts account of Subscription.
     * @param id Subscription id
     * @param where Criteria to match model instances
     */
    subscriptionPrototypeCountAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeCountAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in account of this model.
     * @param id Subscription id
     * @param data
     */
    subscriptionPrototypeCreateAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeCreateAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all account of this model.
     * @param id Subscription id
     */
    subscriptionPrototypeDeleteAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeDeleteAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeDestroyByIdAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeDestroyByIdAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of account relation to an item by id.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeExistsAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeExistsAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeFindByIdAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeFindByIdAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries account of Subscription.
     * @param id Subscription id
     * @param filter
     */
    subscriptionPrototypeGetAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation creater.
     * @param id Subscription id
     * @param refresh
     */
    subscriptionPrototypeGetCreater(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeGetCreater(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     * @param data
     */
    subscriptionPrototypeLinkAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeLinkAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Subscription id
     * @param data An object of model property name/value pairs
     */
    subscriptionPrototypePatchAttributes(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the account relation to an item by id.
     * @param id Subscription id
     * @param fk Foreign key for account
     */
    subscriptionPrototypeUnlinkAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeUnlinkAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for account.
     * @param id Subscription id
     * @param fk Foreign key for account
     * @param data
     */
    subscriptionPrototypeUpdateByIdAccount(params, options) {
        return exports.SubscriptionApiFp.subscriptionPrototypeUpdateByIdAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    subscriptionReplaceByIdPostSubscriptionsidReplace(params, options) {
        return exports.SubscriptionApiFp.subscriptionReplaceByIdPostSubscriptionsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    subscriptionReplaceByIdPutSubscriptionsid(params, options) {
        return exports.SubscriptionApiFp.subscriptionReplaceByIdPutSubscriptionsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options) {
        return exports.SubscriptionApiFp.subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    subscriptionReplaceOrCreatePutSubscriptions(params, options) {
        return exports.SubscriptionApiFp.subscriptionReplaceOrCreatePutSubscriptions(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    subscriptionUpdateAll(params, options) {
        return exports.SubscriptionApiFp.subscriptionUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    subscriptionUpsertWithWhere(params, options) {
        return exports.SubscriptionApiFp.subscriptionUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.SubscriptionApi = SubscriptionApi;
/**
 * SubscriptionApi - factory interface
 */
const SubscriptionApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        subscriptionCount(params, options) {
            return exports.SubscriptionApiFp.subscriptionCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        subscriptionCreate(params, options) {
            return exports.SubscriptionApiFp.subscriptionCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options) {
            return exports.SubscriptionApiFp.subscriptionCreateChangeStreamGetSubscriptionsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options) {
            return exports.SubscriptionApiFp.subscriptionCreateChangeStreamPostSubscriptionsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        subscriptionDeleteById(params, options) {
            return exports.SubscriptionApiFp.subscriptionDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        subscriptionExistsGetSubscriptionsidExists(params, options) {
            return exports.SubscriptionApiFp.subscriptionExistsGetSubscriptionsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        subscriptionExistsHeadSubscriptionsid(params, options) {
            return exports.SubscriptionApiFp.subscriptionExistsHeadSubscriptionsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        subscriptionFind(params, options) {
            return exports.SubscriptionApiFp.subscriptionFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        subscriptionFindById(params, options) {
            return exports.SubscriptionApiFp.subscriptionFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        subscriptionFindOne(params, options) {
            return exports.SubscriptionApiFp.subscriptionFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        subscriptionPatchOrCreate(params, options) {
            return exports.SubscriptionApiFp.subscriptionPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts account of Subscription.
         * @param id Subscription id
         * @param where Criteria to match model instances
         */
        subscriptionPrototypeCountAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeCountAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in account of this model.
         * @param id Subscription id
         * @param data
         */
        subscriptionPrototypeCreateAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeCreateAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all account of this model.
         * @param id Subscription id
         */
        subscriptionPrototypeDeleteAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeDeleteAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for account.
         * @param id Subscription id
         * @param fk Foreign key for account
         */
        subscriptionPrototypeDestroyByIdAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeDestroyByIdAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of account relation to an item by id.
         * @param id Subscription id
         * @param fk Foreign key for account
         */
        subscriptionPrototypeExistsAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeExistsAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for account.
         * @param id Subscription id
         * @param fk Foreign key for account
         */
        subscriptionPrototypeFindByIdAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeFindByIdAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries account of Subscription.
         * @param id Subscription id
         * @param filter
         */
        subscriptionPrototypeGetAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation creater.
         * @param id Subscription id
         * @param refresh
         */
        subscriptionPrototypeGetCreater(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeGetCreater(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for account.
         * @param id Subscription id
         * @param fk Foreign key for account
         * @param data
         */
        subscriptionPrototypeLinkAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeLinkAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Subscription id
         * @param data An object of model property name/value pairs
         */
        subscriptionPrototypePatchAttributes(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the account relation to an item by id.
         * @param id Subscription id
         * @param fk Foreign key for account
         */
        subscriptionPrototypeUnlinkAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeUnlinkAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for account.
         * @param id Subscription id
         * @param fk Foreign key for account
         * @param data
         */
        subscriptionPrototypeUpdateByIdAccount(params, options) {
            return exports.SubscriptionApiFp.subscriptionPrototypeUpdateByIdAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        subscriptionReplaceByIdPostSubscriptionsidReplace(params, options) {
            return exports.SubscriptionApiFp.subscriptionReplaceByIdPostSubscriptionsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        subscriptionReplaceByIdPutSubscriptionsid(params, options) {
            return exports.SubscriptionApiFp.subscriptionReplaceByIdPutSubscriptionsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options) {
            return exports.SubscriptionApiFp.subscriptionReplaceOrCreatePostSubscriptionsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        subscriptionReplaceOrCreatePutSubscriptions(params, options) {
            return exports.SubscriptionApiFp.subscriptionReplaceOrCreatePutSubscriptions(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        subscriptionUpdateAll(params, options) {
            return exports.SubscriptionApiFp.subscriptionUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        subscriptionUpsertWithWhere(params, options) {
            return exports.SubscriptionApiFp.subscriptionUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.SubscriptionApiFactory = SubscriptionApiFactory;
/**
 * TagApi - fetch parameter creator
 */
exports.TagApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        const baseUrl = `/Tags/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagDeleteById');
        }
        const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagExistsGetTagsidExists');
        }
        const baseUrl = `/Tags/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagExistsHeadTagsid');
        }
        const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagFindById');
        }
        const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        const baseUrl = `/Tags/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagPrototypePatchAttributes');
        }
        const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagReplaceByIdPostTagsidReplace');
        }
        const baseUrl = `/Tags/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling tagReplaceByIdPutTagsid');
        }
        const baseUrl = `/Tags/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        const baseUrl = `/Tags/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        const baseUrl = `/Tags/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        const baseUrl = `/Tags/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TagApi - functional programming interface
 */
exports.TagApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreateChangeStreamGetTagsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreateChangeStreamPostTagsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagExistsGetTagsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagExistsHeadTagsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceByIdPostTagsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceByIdPutTagsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceOrCreatePutTags(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TagApi - object-oriented interface
 */
class TagApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        return exports.TagApiFp.tagCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        return exports.TagApiFp.tagCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        return exports.TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        return exports.TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        return exports.TagApiFp.tagDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        return exports.TagApiFp.tagExistsGetTagsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        return exports.TagApiFp.tagExistsHeadTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        return exports.TagApiFp.tagFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        return exports.TagApiFp.tagFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        return exports.TagApiFp.tagFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        return exports.TagApiFp.tagPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        return exports.TagApiFp.tagPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        return exports.TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        return exports.TagApiFp.tagReplaceByIdPutTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        return exports.TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        return exports.TagApiFp.tagReplaceOrCreatePutTags(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        return exports.TagApiFp.tagUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        return exports.TagApiFp.tagUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TagApi = TagApi;
/**
 * TagApi - factory interface
 */
const TagApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        tagCount(params, options) {
            return exports.TagApiFp.tagCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        tagCreate(params, options) {
            return exports.TagApiFp.tagCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        tagCreateChangeStreamGetTagsChangeStream(params, options) {
            return exports.TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        tagCreateChangeStreamPostTagsChangeStream(params, options) {
            return exports.TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        tagDeleteById(params, options) {
            return exports.TagApiFp.tagDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsGetTagsidExists(params, options) {
            return exports.TagApiFp.tagExistsGetTagsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsHeadTagsid(params, options) {
            return exports.TagApiFp.tagExistsHeadTagsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFind(params, options) {
            return exports.TagApiFp.tagFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        tagFindById(params, options) {
            return exports.TagApiFp.tagFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFindOne(params, options) {
            return exports.TagApiFp.tagFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagPatchOrCreate(params, options) {
            return exports.TagApiFp.tagPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Tag id
         * @param data An object of model property name/value pairs
         */
        tagPrototypePatchAttributes(params, options) {
            return exports.TagApiFp.tagPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPostTagsidReplace(params, options) {
            return exports.TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPutTagsid(params, options) {
            return exports.TagApiFp.tagReplaceByIdPutTagsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
            return exports.TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePutTags(params, options) {
            return exports.TagApiFp.tagReplaceOrCreatePutTags(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpdateAll(params, options) {
            return exports.TagApiFp.tagUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpsertWithWhere(params, options) {
            return exports.TagApiFp.tagUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TagApiFactory = TagApiFactory;
/**
 * TrackApi - fetch parameter creator
 */
exports.TrackApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackCount(params, options) {
        const baseUrl = `/Tracks/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackCreate(params, options) {
        const baseUrl = `/Tracks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackCreateChangeStreamGetTracksChangeStream(params, options) {
        const baseUrl = `/Tracks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackCreateChangeStreamPostTracksChangeStream(params, options) {
        const baseUrl = `/Tracks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackDeleteById');
        }
        const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackExistsGetTracksidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackExistsGetTracksidExists');
        }
        const baseUrl = `/Tracks/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackExistsHeadTracksid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackExistsHeadTracksid');
        }
        const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackFind(params, options) {
        const baseUrl = `/Tracks`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackFindById');
        }
        const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackFindOne(params, options) {
        const baseUrl = `/Tracks/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackPatchOrCreate(params, options) {
        const baseUrl = `/Tracks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts cart of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCountCart');
        }
        const baseUrl = `/Tracks/{id}/cart/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts composers of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCountComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts downloaders of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCountDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts genres of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCountGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts moods of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCountMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts playlist of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCountPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCreateCart');
        }
        const baseUrl = `/Tracks/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in composers of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCreateComposers');
        }
        const baseUrl = `/Tracks/{id}/composers`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in downloaders of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCreateDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in genres of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCreateGenres');
        }
        const baseUrl = `/Tracks/{id}/genres`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in moods of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCreateMoods');
        }
        const baseUrl = `/Tracks/{id}/moods`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in playlist of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreatePlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeCreatePlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all cart of this model.
     * @param id Track id
     */
    trackPrototypeDeleteCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDeleteCart');
        }
        const baseUrl = `/Tracks/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all composers of this model.
     * @param id Track id
     */
    trackPrototypeDeleteComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDeleteComposers');
        }
        const baseUrl = `/Tracks/{id}/composers`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all downloaders of this model.
     * @param id Track id
     */
    trackPrototypeDeleteDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDeleteDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all genres of this model.
     * @param id Track id
     */
    trackPrototypeDeleteGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDeleteGenres');
        }
        const baseUrl = `/Tracks/{id}/genres`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all moods of this model.
     * @param id Track id
     */
    trackPrototypeDeleteMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDeleteMoods');
        }
        const baseUrl = `/Tracks/{id}/moods`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all playlist of this model.
     * @param id Track id
     */
    trackPrototypeDeletePlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDeletePlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeDestroyByIdCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdCart');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdCart');
        }
        const baseUrl = `/Tracks/{id}/cart/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeDestroyByIdComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdComposers');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeDestroyByIdDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdDownloaders');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeDestroyByIdGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdGenres');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeDestroyByIdMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdMoods');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeDestroyByIdPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeDestroyByIdPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeDestroyByIdPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of cart relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeExistsCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeExistsCart');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeExistsCart');
        }
        const baseUrl = `/Tracks/{id}/cart/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of composers relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeExistsComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeExistsComposers');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeExistsComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of downloaders relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeExistsDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeExistsDownloaders');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeExistsDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of genres relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeExistsGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeExistsGenres');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeExistsGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of moods relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeExistsMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeExistsMoods');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeExistsMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of playlist relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeExistsPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeExistsPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeExistsPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeFindByIdCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeFindByIdCart');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdCart');
        }
        const baseUrl = `/Tracks/{id}/cart/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeFindByIdComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeFindByIdComposers');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeFindByIdDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeFindByIdDownloaders');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeFindByIdGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeFindByIdGenres');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeFindByIdMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeFindByIdMoods');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeFindByIdPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeFindByIdPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeFindByIdPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries cart of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeGetCart');
        }
        const baseUrl = `/Tracks/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries composers of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeGetComposers');
        }
        const baseUrl = `/Tracks/{id}/composers`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries downloaders of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeGetDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries genres of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeGetGenres');
        }
        const baseUrl = `/Tracks/{id}/genres`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries moods of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeGetMoods');
        }
        const baseUrl = `/Tracks/{id}/moods`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries playlist of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeGetPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     * @param data
     */
    trackPrototypeLinkCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeLinkCart');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeLinkCart');
        }
        const baseUrl = `/Tracks/{id}/cart/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     * @param data
     */
    trackPrototypeLinkComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeLinkComposers');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeLinkComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     * @param data
     */
    trackPrototypeLinkDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeLinkDownloaders');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeLinkDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     * @param data
     */
    trackPrototypeLinkGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeLinkGenres');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeLinkGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     * @param data
     */
    trackPrototypeLinkMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeLinkMoods');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeLinkMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     * @param data
     */
    trackPrototypeLinkPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeLinkPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeLinkPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Track id
     * @param data An object of model property name/value pairs
     */
    trackPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypePatchAttributes');
        }
        const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the cart relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeUnlinkCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUnlinkCart');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkCart');
        }
        const baseUrl = `/Tracks/{id}/cart/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the composers relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeUnlinkComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUnlinkComposers');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the downloaders relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeUnlinkDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUnlinkDownloaders');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the genres relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeUnlinkGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUnlinkGenres');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the moods relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeUnlinkMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUnlinkMoods');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the playlist relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeUnlinkPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUnlinkPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUnlinkPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/rel/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     * @param data
     */
    trackPrototypeUpdateByIdCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdCart');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdCart');
        }
        const baseUrl = `/Tracks/{id}/cart/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     * @param data
     */
    trackPrototypeUpdateByIdComposers(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdComposers');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdComposers');
        }
        const baseUrl = `/Tracks/{id}/composers/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     * @param data
     */
    trackPrototypeUpdateByIdDownloaders(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdDownloaders');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdDownloaders');
        }
        const baseUrl = `/Tracks/{id}/downloaders/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     * @param data
     */
    trackPrototypeUpdateByIdGenres(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdGenres');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdGenres');
        }
        const baseUrl = `/Tracks/{id}/genres/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     * @param data
     */
    trackPrototypeUpdateByIdMoods(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdMoods');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdMoods');
        }
        const baseUrl = `/Tracks/{id}/moods/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     * @param data
     */
    trackPrototypeUpdateByIdPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackPrototypeUpdateByIdPlaylist');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling trackPrototypeUpdateByIdPlaylist');
        }
        const baseUrl = `/Tracks/{id}/playlist/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackReplaceByIdPostTracksidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackReplaceByIdPostTracksidReplace');
        }
        const baseUrl = `/Tracks/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackReplaceByIdPutTracksid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackReplaceByIdPutTracksid');
        }
        const baseUrl = `/Tracks/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackReplaceOrCreatePostTracksReplaceOrCreate(params, options) {
        const baseUrl = `/Tracks/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackReplaceOrCreatePutTracks(params, options) {
        const baseUrl = `/Tracks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackUpdateAll(params, options) {
        const baseUrl = `/Tracks/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackUpsertWithWhere(params, options) {
        const baseUrl = `/Tracks/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TrackApi - functional programming interface
 */
exports.TrackApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackCount(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackCreate(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackCreateChangeStreamGetTracksChangeStream(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackCreateChangeStreamGetTracksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackCreateChangeStreamPostTracksChangeStream(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackCreateChangeStreamPostTracksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackDeleteById(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackExistsGetTracksidExists(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackExistsGetTracksidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackExistsHeadTracksid(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackExistsHeadTracksid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackFind(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackFindById(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackFindOne(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackPatchOrCreate(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts cart of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCountCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts composers of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCountComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts downloaders of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCountDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts genres of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCountGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts moods of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCountMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts playlist of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCountPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCreateCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in composers of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCreateComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in downloaders of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCreateDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in genres of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCreateGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in moods of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCreateMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in playlist of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreatePlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeCreatePlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all cart of this model.
     * @param id Track id
     */
    trackPrototypeDeleteCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDeleteCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all composers of this model.
     * @param id Track id
     */
    trackPrototypeDeleteComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDeleteComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all downloaders of this model.
     * @param id Track id
     */
    trackPrototypeDeleteDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDeleteDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all genres of this model.
     * @param id Track id
     */
    trackPrototypeDeleteGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDeleteGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all moods of this model.
     * @param id Track id
     */
    trackPrototypeDeleteMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDeleteMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all playlist of this model.
     * @param id Track id
     */
    trackPrototypeDeletePlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDeletePlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeDestroyByIdCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDestroyByIdCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeDestroyByIdComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDestroyByIdComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeDestroyByIdDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDestroyByIdDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeDestroyByIdGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDestroyByIdGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeDestroyByIdMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDestroyByIdMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeDestroyByIdPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeDestroyByIdPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of cart relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeExistsCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeExistsCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of composers relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeExistsComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeExistsComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of downloaders relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeExistsDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeExistsDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of genres relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeExistsGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeExistsGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of moods relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeExistsMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeExistsMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of playlist relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeExistsPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeExistsPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeFindByIdCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeFindByIdCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeFindByIdComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeFindByIdComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeFindByIdDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeFindByIdDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeFindByIdGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeFindByIdGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeFindByIdMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeFindByIdMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeFindByIdPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeFindByIdPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries cart of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeGetCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries composers of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeGetComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries downloaders of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeGetDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries genres of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeGetGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries moods of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeGetMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries playlist of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeGetPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     * @param data
     */
    trackPrototypeLinkCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeLinkCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     * @param data
     */
    trackPrototypeLinkComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeLinkComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     * @param data
     */
    trackPrototypeLinkDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeLinkDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     * @param data
     */
    trackPrototypeLinkGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeLinkGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     * @param data
     */
    trackPrototypeLinkMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeLinkMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     * @param data
     */
    trackPrototypeLinkPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeLinkPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Track id
     * @param data An object of model property name/value pairs
     */
    trackPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the cart relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeUnlinkCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUnlinkCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the composers relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeUnlinkComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUnlinkComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the downloaders relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeUnlinkDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUnlinkDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the genres relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeUnlinkGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUnlinkGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the moods relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeUnlinkMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUnlinkMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the playlist relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeUnlinkPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUnlinkPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     * @param data
     */
    trackPrototypeUpdateByIdCart(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUpdateByIdCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     * @param data
     */
    trackPrototypeUpdateByIdComposers(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUpdateByIdComposers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     * @param data
     */
    trackPrototypeUpdateByIdDownloaders(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUpdateByIdDownloaders(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     * @param data
     */
    trackPrototypeUpdateByIdGenres(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUpdateByIdGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     * @param data
     */
    trackPrototypeUpdateByIdMoods(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUpdateByIdMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     * @param data
     */
    trackPrototypeUpdateByIdPlaylist(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackPrototypeUpdateByIdPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackReplaceByIdPostTracksidReplace(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackReplaceByIdPostTracksidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackReplaceByIdPutTracksid(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackReplaceByIdPutTracksid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackReplaceOrCreatePostTracksReplaceOrCreate(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackReplaceOrCreatePostTracksReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackReplaceOrCreatePutTracks(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackReplaceOrCreatePutTracks(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackUpdateAll(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackUpsertWithWhere(params, options) {
        const fetchArgs = exports.TrackApiFetchParamCreator.trackUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TrackApi - object-oriented interface
 */
class TrackApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackCount(params, options) {
        return exports.TrackApiFp.trackCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackCreate(params, options) {
        return exports.TrackApiFp.trackCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackCreateChangeStreamGetTracksChangeStream(params, options) {
        return exports.TrackApiFp.trackCreateChangeStreamGetTracksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackCreateChangeStreamPostTracksChangeStream(params, options) {
        return exports.TrackApiFp.trackCreateChangeStreamPostTracksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackDeleteById(params, options) {
        return exports.TrackApiFp.trackDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackExistsGetTracksidExists(params, options) {
        return exports.TrackApiFp.trackExistsGetTracksidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackExistsHeadTracksid(params, options) {
        return exports.TrackApiFp.trackExistsHeadTracksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackFind(params, options) {
        return exports.TrackApiFp.trackFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackFindById(params, options) {
        return exports.TrackApiFp.trackFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackFindOne(params, options) {
        return exports.TrackApiFp.trackFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackPatchOrCreate(params, options) {
        return exports.TrackApiFp.trackPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts cart of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountCart(params, options) {
        return exports.TrackApiFp.trackPrototypeCountCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts composers of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeCountComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts downloaders of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeCountDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts genres of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeCountGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts moods of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeCountMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts playlist of Track.
     * @param id Track id
     * @param where Criteria to match model instances
     */
    trackPrototypeCountPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeCountPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateCart(params, options) {
        return exports.TrackApiFp.trackPrototypeCreateCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in composers of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeCreateComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in downloaders of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeCreateDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in genres of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeCreateGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in moods of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreateMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeCreateMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in playlist of this model.
     * @param id Track id
     * @param data
     */
    trackPrototypeCreatePlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeCreatePlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all cart of this model.
     * @param id Track id
     */
    trackPrototypeDeleteCart(params, options) {
        return exports.TrackApiFp.trackPrototypeDeleteCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all composers of this model.
     * @param id Track id
     */
    trackPrototypeDeleteComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeDeleteComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all downloaders of this model.
     * @param id Track id
     */
    trackPrototypeDeleteDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeDeleteDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all genres of this model.
     * @param id Track id
     */
    trackPrototypeDeleteGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeDeleteGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all moods of this model.
     * @param id Track id
     */
    trackPrototypeDeleteMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeDeleteMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all playlist of this model.
     * @param id Track id
     */
    trackPrototypeDeletePlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeDeletePlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeDestroyByIdCart(params, options) {
        return exports.TrackApiFp.trackPrototypeDestroyByIdCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeDestroyByIdComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeDestroyByIdComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeDestroyByIdDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeDestroyByIdDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeDestroyByIdGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeDestroyByIdGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeDestroyByIdMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeDestroyByIdMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeDestroyByIdPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeDestroyByIdPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of cart relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeExistsCart(params, options) {
        return exports.TrackApiFp.trackPrototypeExistsCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of composers relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeExistsComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeExistsComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of downloaders relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeExistsDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeExistsDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of genres relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeExistsGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeExistsGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of moods relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeExistsMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeExistsMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of playlist relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeExistsPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeExistsPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeFindByIdCart(params, options) {
        return exports.TrackApiFp.trackPrototypeFindByIdCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeFindByIdComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeFindByIdComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeFindByIdDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeFindByIdDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeFindByIdGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeFindByIdGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeFindByIdMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeFindByIdMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeFindByIdPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeFindByIdPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries cart of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetCart(params, options) {
        return exports.TrackApiFp.trackPrototypeGetCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries composers of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeGetComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries downloaders of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeGetDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries genres of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeGetGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries moods of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeGetMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries playlist of Track.
     * @param id Track id
     * @param filter
     */
    trackPrototypeGetPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeGetPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     * @param data
     */
    trackPrototypeLinkCart(params, options) {
        return exports.TrackApiFp.trackPrototypeLinkCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     * @param data
     */
    trackPrototypeLinkComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeLinkComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     * @param data
     */
    trackPrototypeLinkDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeLinkDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     * @param data
     */
    trackPrototypeLinkGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeLinkGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     * @param data
     */
    trackPrototypeLinkMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeLinkMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     * @param data
     */
    trackPrototypeLinkPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeLinkPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Track id
     * @param data An object of model property name/value pairs
     */
    trackPrototypePatchAttributes(params, options) {
        return exports.TrackApiFp.trackPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the cart relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for cart
     */
    trackPrototypeUnlinkCart(params, options) {
        return exports.TrackApiFp.trackPrototypeUnlinkCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the composers relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for composers
     */
    trackPrototypeUnlinkComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeUnlinkComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the downloaders relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for downloaders
     */
    trackPrototypeUnlinkDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeUnlinkDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the genres relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for genres
     */
    trackPrototypeUnlinkGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeUnlinkGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the moods relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for moods
     */
    trackPrototypeUnlinkMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeUnlinkMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the playlist relation to an item by id.
     * @param id Track id
     * @param fk Foreign key for playlist
     */
    trackPrototypeUnlinkPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeUnlinkPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for cart.
     * @param id Track id
     * @param fk Foreign key for cart
     * @param data
     */
    trackPrototypeUpdateByIdCart(params, options) {
        return exports.TrackApiFp.trackPrototypeUpdateByIdCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for composers.
     * @param id Track id
     * @param fk Foreign key for composers
     * @param data
     */
    trackPrototypeUpdateByIdComposers(params, options) {
        return exports.TrackApiFp.trackPrototypeUpdateByIdComposers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for downloaders.
     * @param id Track id
     * @param fk Foreign key for downloaders
     * @param data
     */
    trackPrototypeUpdateByIdDownloaders(params, options) {
        return exports.TrackApiFp.trackPrototypeUpdateByIdDownloaders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for genres.
     * @param id Track id
     * @param fk Foreign key for genres
     * @param data
     */
    trackPrototypeUpdateByIdGenres(params, options) {
        return exports.TrackApiFp.trackPrototypeUpdateByIdGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for moods.
     * @param id Track id
     * @param fk Foreign key for moods
     * @param data
     */
    trackPrototypeUpdateByIdMoods(params, options) {
        return exports.TrackApiFp.trackPrototypeUpdateByIdMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for playlist.
     * @param id Track id
     * @param fk Foreign key for playlist
     * @param data
     */
    trackPrototypeUpdateByIdPlaylist(params, options) {
        return exports.TrackApiFp.trackPrototypeUpdateByIdPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackReplaceByIdPostTracksidReplace(params, options) {
        return exports.TrackApiFp.trackReplaceByIdPostTracksidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackReplaceByIdPutTracksid(params, options) {
        return exports.TrackApiFp.trackReplaceByIdPutTracksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackReplaceOrCreatePostTracksReplaceOrCreate(params, options) {
        return exports.TrackApiFp.trackReplaceOrCreatePostTracksReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackReplaceOrCreatePutTracks(params, options) {
        return exports.TrackApiFp.trackReplaceOrCreatePutTracks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackUpdateAll(params, options) {
        return exports.TrackApiFp.trackUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackUpsertWithWhere(params, options) {
        return exports.TrackApiFp.trackUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TrackApi = TrackApi;
/**
 * TrackApi - factory interface
 */
const TrackApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        trackCount(params, options) {
            return exports.TrackApiFp.trackCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        trackCreate(params, options) {
            return exports.TrackApiFp.trackCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackCreateChangeStreamGetTracksChangeStream(params, options) {
            return exports.TrackApiFp.trackCreateChangeStreamGetTracksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackCreateChangeStreamPostTracksChangeStream(params, options) {
            return exports.TrackApiFp.trackCreateChangeStreamPostTracksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        trackDeleteById(params, options) {
            return exports.TrackApiFp.trackDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackExistsGetTracksidExists(params, options) {
            return exports.TrackApiFp.trackExistsGetTracksidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackExistsHeadTracksid(params, options) {
            return exports.TrackApiFp.trackExistsHeadTracksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackFind(params, options) {
            return exports.TrackApiFp.trackFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        trackFindById(params, options) {
            return exports.TrackApiFp.trackFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackFindOne(params, options) {
            return exports.TrackApiFp.trackFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackPatchOrCreate(params, options) {
            return exports.TrackApiFp.trackPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts cart of Track.
         * @param id Track id
         * @param where Criteria to match model instances
         */
        trackPrototypeCountCart(params, options) {
            return exports.TrackApiFp.trackPrototypeCountCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts composers of Track.
         * @param id Track id
         * @param where Criteria to match model instances
         */
        trackPrototypeCountComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeCountComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts downloaders of Track.
         * @param id Track id
         * @param where Criteria to match model instances
         */
        trackPrototypeCountDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeCountDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts genres of Track.
         * @param id Track id
         * @param where Criteria to match model instances
         */
        trackPrototypeCountGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeCountGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts moods of Track.
         * @param id Track id
         * @param where Criteria to match model instances
         */
        trackPrototypeCountMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeCountMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts playlist of Track.
         * @param id Track id
         * @param where Criteria to match model instances
         */
        trackPrototypeCountPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeCountPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in cart of this model.
         * @param id Track id
         * @param data
         */
        trackPrototypeCreateCart(params, options) {
            return exports.TrackApiFp.trackPrototypeCreateCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in composers of this model.
         * @param id Track id
         * @param data
         */
        trackPrototypeCreateComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeCreateComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in downloaders of this model.
         * @param id Track id
         * @param data
         */
        trackPrototypeCreateDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeCreateDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in genres of this model.
         * @param id Track id
         * @param data
         */
        trackPrototypeCreateGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeCreateGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in moods of this model.
         * @param id Track id
         * @param data
         */
        trackPrototypeCreateMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeCreateMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in playlist of this model.
         * @param id Track id
         * @param data
         */
        trackPrototypeCreatePlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeCreatePlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all cart of this model.
         * @param id Track id
         */
        trackPrototypeDeleteCart(params, options) {
            return exports.TrackApiFp.trackPrototypeDeleteCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all composers of this model.
         * @param id Track id
         */
        trackPrototypeDeleteComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeDeleteComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all downloaders of this model.
         * @param id Track id
         */
        trackPrototypeDeleteDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeDeleteDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all genres of this model.
         * @param id Track id
         */
        trackPrototypeDeleteGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeDeleteGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all moods of this model.
         * @param id Track id
         */
        trackPrototypeDeleteMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeDeleteMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all playlist of this model.
         * @param id Track id
         */
        trackPrototypeDeletePlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeDeletePlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for cart.
         * @param id Track id
         * @param fk Foreign key for cart
         */
        trackPrototypeDestroyByIdCart(params, options) {
            return exports.TrackApiFp.trackPrototypeDestroyByIdCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for composers.
         * @param id Track id
         * @param fk Foreign key for composers
         */
        trackPrototypeDestroyByIdComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeDestroyByIdComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for downloaders.
         * @param id Track id
         * @param fk Foreign key for downloaders
         */
        trackPrototypeDestroyByIdDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeDestroyByIdDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for genres.
         * @param id Track id
         * @param fk Foreign key for genres
         */
        trackPrototypeDestroyByIdGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeDestroyByIdGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for moods.
         * @param id Track id
         * @param fk Foreign key for moods
         */
        trackPrototypeDestroyByIdMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeDestroyByIdMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for playlist.
         * @param id Track id
         * @param fk Foreign key for playlist
         */
        trackPrototypeDestroyByIdPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeDestroyByIdPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of cart relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for cart
         */
        trackPrototypeExistsCart(params, options) {
            return exports.TrackApiFp.trackPrototypeExistsCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of composers relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for composers
         */
        trackPrototypeExistsComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeExistsComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of downloaders relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for downloaders
         */
        trackPrototypeExistsDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeExistsDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of genres relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for genres
         */
        trackPrototypeExistsGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeExistsGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of moods relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for moods
         */
        trackPrototypeExistsMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeExistsMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of playlist relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for playlist
         */
        trackPrototypeExistsPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeExistsPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for cart.
         * @param id Track id
         * @param fk Foreign key for cart
         */
        trackPrototypeFindByIdCart(params, options) {
            return exports.TrackApiFp.trackPrototypeFindByIdCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for composers.
         * @param id Track id
         * @param fk Foreign key for composers
         */
        trackPrototypeFindByIdComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeFindByIdComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for downloaders.
         * @param id Track id
         * @param fk Foreign key for downloaders
         */
        trackPrototypeFindByIdDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeFindByIdDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for genres.
         * @param id Track id
         * @param fk Foreign key for genres
         */
        trackPrototypeFindByIdGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeFindByIdGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for moods.
         * @param id Track id
         * @param fk Foreign key for moods
         */
        trackPrototypeFindByIdMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeFindByIdMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for playlist.
         * @param id Track id
         * @param fk Foreign key for playlist
         */
        trackPrototypeFindByIdPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeFindByIdPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries cart of Track.
         * @param id Track id
         * @param filter
         */
        trackPrototypeGetCart(params, options) {
            return exports.TrackApiFp.trackPrototypeGetCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries composers of Track.
         * @param id Track id
         * @param filter
         */
        trackPrototypeGetComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeGetComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries downloaders of Track.
         * @param id Track id
         * @param filter
         */
        trackPrototypeGetDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeGetDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries genres of Track.
         * @param id Track id
         * @param filter
         */
        trackPrototypeGetGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeGetGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries moods of Track.
         * @param id Track id
         * @param filter
         */
        trackPrototypeGetMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeGetMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries playlist of Track.
         * @param id Track id
         * @param filter
         */
        trackPrototypeGetPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeGetPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for cart.
         * @param id Track id
         * @param fk Foreign key for cart
         * @param data
         */
        trackPrototypeLinkCart(params, options) {
            return exports.TrackApiFp.trackPrototypeLinkCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for composers.
         * @param id Track id
         * @param fk Foreign key for composers
         * @param data
         */
        trackPrototypeLinkComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeLinkComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for downloaders.
         * @param id Track id
         * @param fk Foreign key for downloaders
         * @param data
         */
        trackPrototypeLinkDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeLinkDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for genres.
         * @param id Track id
         * @param fk Foreign key for genres
         * @param data
         */
        trackPrototypeLinkGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeLinkGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for moods.
         * @param id Track id
         * @param fk Foreign key for moods
         * @param data
         */
        trackPrototypeLinkMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeLinkMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for playlist.
         * @param id Track id
         * @param fk Foreign key for playlist
         * @param data
         */
        trackPrototypeLinkPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeLinkPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Track id
         * @param data An object of model property name/value pairs
         */
        trackPrototypePatchAttributes(params, options) {
            return exports.TrackApiFp.trackPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the cart relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for cart
         */
        trackPrototypeUnlinkCart(params, options) {
            return exports.TrackApiFp.trackPrototypeUnlinkCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the composers relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for composers
         */
        trackPrototypeUnlinkComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeUnlinkComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the downloaders relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for downloaders
         */
        trackPrototypeUnlinkDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeUnlinkDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the genres relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for genres
         */
        trackPrototypeUnlinkGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeUnlinkGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the moods relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for moods
         */
        trackPrototypeUnlinkMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeUnlinkMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the playlist relation to an item by id.
         * @param id Track id
         * @param fk Foreign key for playlist
         */
        trackPrototypeUnlinkPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeUnlinkPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for cart.
         * @param id Track id
         * @param fk Foreign key for cart
         * @param data
         */
        trackPrototypeUpdateByIdCart(params, options) {
            return exports.TrackApiFp.trackPrototypeUpdateByIdCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for composers.
         * @param id Track id
         * @param fk Foreign key for composers
         * @param data
         */
        trackPrototypeUpdateByIdComposers(params, options) {
            return exports.TrackApiFp.trackPrototypeUpdateByIdComposers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for downloaders.
         * @param id Track id
         * @param fk Foreign key for downloaders
         * @param data
         */
        trackPrototypeUpdateByIdDownloaders(params, options) {
            return exports.TrackApiFp.trackPrototypeUpdateByIdDownloaders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for genres.
         * @param id Track id
         * @param fk Foreign key for genres
         * @param data
         */
        trackPrototypeUpdateByIdGenres(params, options) {
            return exports.TrackApiFp.trackPrototypeUpdateByIdGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for moods.
         * @param id Track id
         * @param fk Foreign key for moods
         * @param data
         */
        trackPrototypeUpdateByIdMoods(params, options) {
            return exports.TrackApiFp.trackPrototypeUpdateByIdMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for playlist.
         * @param id Track id
         * @param fk Foreign key for playlist
         * @param data
         */
        trackPrototypeUpdateByIdPlaylist(params, options) {
            return exports.TrackApiFp.trackPrototypeUpdateByIdPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackReplaceByIdPostTracksidReplace(params, options) {
            return exports.TrackApiFp.trackReplaceByIdPostTracksidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackReplaceByIdPutTracksid(params, options) {
            return exports.TrackApiFp.trackReplaceByIdPutTracksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackReplaceOrCreatePostTracksReplaceOrCreate(params, options) {
            return exports.TrackApiFp.trackReplaceOrCreatePostTracksReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackReplaceOrCreatePutTracks(params, options) {
            return exports.TrackApiFp.trackReplaceOrCreatePutTracks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackUpdateAll(params, options) {
            return exports.TrackApiFp.trackUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackUpsertWithWhere(params, options) {
            return exports.TrackApiFp.trackUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TrackApiFactory = TrackApiFactory;
/**
 * TrackGenreApi - fetch parameter creator
 */
exports.TrackGenreApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackGenreCount(params, options) {
        const baseUrl = `/TrackGenres/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackGenreCreate(params, options) {
        const baseUrl = `/TrackGenres`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options) {
        const baseUrl = `/TrackGenres/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options) {
        const baseUrl = `/TrackGenres/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackGenreDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenreDeleteById');
        }
        const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackGenreExistsGetTrackGenresidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenreExistsGetTrackGenresidExists');
        }
        const baseUrl = `/TrackGenres/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackGenreExistsHeadTrackGenresid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenreExistsHeadTrackGenresid');
        }
        const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackGenreFind(params, options) {
        const baseUrl = `/TrackGenres`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackGenreFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenreFindById');
        }
        const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackGenreFindOne(params, options) {
        const baseUrl = `/TrackGenres/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenrePatchOrCreate(params, options) {
        const baseUrl = `/TrackGenres`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation genre.
     * @param id TrackGenre id
     * @param refresh
     */
    trackGenrePrototypeGetGenre(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenrePrototypeGetGenre');
        }
        const baseUrl = `/TrackGenres/{id}/genre`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackGenre id
     * @param refresh
     */
    trackGenrePrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenrePrototypeGetTrack');
        }
        const baseUrl = `/TrackGenres/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackGenre id
     * @param data An object of model property name/value pairs
     */
    trackGenrePrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenrePrototypePatchAttributes');
        }
        const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackGenreReplaceByIdPostTrackGenresidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenreReplaceByIdPostTrackGenresidReplace');
        }
        const baseUrl = `/TrackGenres/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackGenreReplaceByIdPutTrackGenresid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackGenreReplaceByIdPutTrackGenresid');
        }
        const baseUrl = `/TrackGenres/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options) {
        const baseUrl = `/TrackGenres/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenreReplaceOrCreatePutTrackGenres(params, options) {
        const baseUrl = `/TrackGenres`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackGenreUpdateAll(params, options) {
        const baseUrl = `/TrackGenres/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackGenreUpsertWithWhere(params, options) {
        const baseUrl = `/TrackGenres/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TrackGenreApi - functional programming interface
 */
exports.TrackGenreApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackGenreCount(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackGenreCreate(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackGenreDeleteById(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackGenreExistsGetTrackGenresidExists(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreExistsGetTrackGenresidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackGenreExistsHeadTrackGenresid(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreExistsHeadTrackGenresid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackGenreFind(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackGenreFindById(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackGenreFindOne(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenrePatchOrCreate(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenrePatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation genre.
     * @param id TrackGenre id
     * @param refresh
     */
    trackGenrePrototypeGetGenre(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenrePrototypeGetGenre(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackGenre id
     * @param refresh
     */
    trackGenrePrototypeGetTrack(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenrePrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackGenre id
     * @param data An object of model property name/value pairs
     */
    trackGenrePrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenrePrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackGenreReplaceByIdPostTrackGenresidReplace(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreReplaceByIdPostTrackGenresidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackGenreReplaceByIdPutTrackGenresid(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreReplaceByIdPutTrackGenresid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenreReplaceOrCreatePutTrackGenres(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreReplaceOrCreatePutTrackGenres(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackGenreUpdateAll(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackGenreUpsertWithWhere(params, options) {
        const fetchArgs = exports.TrackGenreApiFetchParamCreator.trackGenreUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TrackGenreApi - object-oriented interface
 */
class TrackGenreApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackGenreCount(params, options) {
        return exports.TrackGenreApiFp.trackGenreCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackGenreCreate(params, options) {
        return exports.TrackGenreApiFp.trackGenreCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options) {
        return exports.TrackGenreApiFp.trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options) {
        return exports.TrackGenreApiFp.trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackGenreDeleteById(params, options) {
        return exports.TrackGenreApiFp.trackGenreDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackGenreExistsGetTrackGenresidExists(params, options) {
        return exports.TrackGenreApiFp.trackGenreExistsGetTrackGenresidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackGenreExistsHeadTrackGenresid(params, options) {
        return exports.TrackGenreApiFp.trackGenreExistsHeadTrackGenresid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackGenreFind(params, options) {
        return exports.TrackGenreApiFp.trackGenreFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackGenreFindById(params, options) {
        return exports.TrackGenreApiFp.trackGenreFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackGenreFindOne(params, options) {
        return exports.TrackGenreApiFp.trackGenreFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenrePatchOrCreate(params, options) {
        return exports.TrackGenreApiFp.trackGenrePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation genre.
     * @param id TrackGenre id
     * @param refresh
     */
    trackGenrePrototypeGetGenre(params, options) {
        return exports.TrackGenreApiFp.trackGenrePrototypeGetGenre(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackGenre id
     * @param refresh
     */
    trackGenrePrototypeGetTrack(params, options) {
        return exports.TrackGenreApiFp.trackGenrePrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackGenre id
     * @param data An object of model property name/value pairs
     */
    trackGenrePrototypePatchAttributes(params, options) {
        return exports.TrackGenreApiFp.trackGenrePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackGenreReplaceByIdPostTrackGenresidReplace(params, options) {
        return exports.TrackGenreApiFp.trackGenreReplaceByIdPostTrackGenresidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackGenreReplaceByIdPutTrackGenresid(params, options) {
        return exports.TrackGenreApiFp.trackGenreReplaceByIdPutTrackGenresid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options) {
        return exports.TrackGenreApiFp.trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackGenreReplaceOrCreatePutTrackGenres(params, options) {
        return exports.TrackGenreApiFp.trackGenreReplaceOrCreatePutTrackGenres(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackGenreUpdateAll(params, options) {
        return exports.TrackGenreApiFp.trackGenreUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackGenreUpsertWithWhere(params, options) {
        return exports.TrackGenreApiFp.trackGenreUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TrackGenreApi = TrackGenreApi;
/**
 * TrackGenreApi - factory interface
 */
const TrackGenreApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        trackGenreCount(params, options) {
            return exports.TrackGenreApiFp.trackGenreCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        trackGenreCreate(params, options) {
            return exports.TrackGenreApiFp.trackGenreCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options) {
            return exports.TrackGenreApiFp.trackGenreCreateChangeStreamGetTrackGenresChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options) {
            return exports.TrackGenreApiFp.trackGenreCreateChangeStreamPostTrackGenresChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        trackGenreDeleteById(params, options) {
            return exports.TrackGenreApiFp.trackGenreDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackGenreExistsGetTrackGenresidExists(params, options) {
            return exports.TrackGenreApiFp.trackGenreExistsGetTrackGenresidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackGenreExistsHeadTrackGenresid(params, options) {
            return exports.TrackGenreApiFp.trackGenreExistsHeadTrackGenresid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackGenreFind(params, options) {
            return exports.TrackGenreApiFp.trackGenreFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        trackGenreFindById(params, options) {
            return exports.TrackGenreApiFp.trackGenreFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackGenreFindOne(params, options) {
            return exports.TrackGenreApiFp.trackGenreFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackGenrePatchOrCreate(params, options) {
            return exports.TrackGenreApiFp.trackGenrePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation genre.
         * @param id TrackGenre id
         * @param refresh
         */
        trackGenrePrototypeGetGenre(params, options) {
            return exports.TrackGenreApiFp.trackGenrePrototypeGetGenre(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation track.
         * @param id TrackGenre id
         * @param refresh
         */
        trackGenrePrototypeGetTrack(params, options) {
            return exports.TrackGenreApiFp.trackGenrePrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id TrackGenre id
         * @param data An object of model property name/value pairs
         */
        trackGenrePrototypePatchAttributes(params, options) {
            return exports.TrackGenreApiFp.trackGenrePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackGenreReplaceByIdPostTrackGenresidReplace(params, options) {
            return exports.TrackGenreApiFp.trackGenreReplaceByIdPostTrackGenresidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackGenreReplaceByIdPutTrackGenresid(params, options) {
            return exports.TrackGenreApiFp.trackGenreReplaceByIdPutTrackGenresid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options) {
            return exports.TrackGenreApiFp.trackGenreReplaceOrCreatePostTrackGenresReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackGenreReplaceOrCreatePutTrackGenres(params, options) {
            return exports.TrackGenreApiFp.trackGenreReplaceOrCreatePutTrackGenres(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackGenreUpdateAll(params, options) {
            return exports.TrackGenreApiFp.trackGenreUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackGenreUpsertWithWhere(params, options) {
            return exports.TrackGenreApiFp.trackGenreUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TrackGenreApiFactory = TrackGenreApiFactory;
/**
 * TrackInCartApi - fetch parameter creator
 */
exports.TrackInCartApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackInCartCount(params, options) {
        const baseUrl = `/TrackInCarts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackInCartCreate(params, options) {
        const baseUrl = `/TrackInCarts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options) {
        const baseUrl = `/TrackInCarts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options) {
        const baseUrl = `/TrackInCarts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackInCartDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartDeleteById');
        }
        const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInCartExistsGetTrackInCartsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartExistsGetTrackInCartsidExists');
        }
        const baseUrl = `/TrackInCarts/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInCartExistsHeadTrackInCartsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartExistsHeadTrackInCartsid');
        }
        const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInCartFind(params, options) {
        const baseUrl = `/TrackInCarts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackInCartFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartFindById');
        }
        const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInCartFindOne(params, options) {
        const baseUrl = `/TrackInCarts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartPatchOrCreate(params, options) {
        const baseUrl = `/TrackInCarts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation cart.
     * @param id TrackInCart id
     * @param refresh
     */
    trackInCartPrototypeGetCart(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartPrototypeGetCart');
        }
        const baseUrl = `/TrackInCarts/{id}/cart`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackInCart id
     * @param refresh
     */
    trackInCartPrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartPrototypeGetTrack');
        }
        const baseUrl = `/TrackInCarts/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackInCart id
     * @param data An object of model property name/value pairs
     */
    trackInCartPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartPrototypePatchAttributes');
        }
        const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInCartReplaceByIdPostTrackInCartsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartReplaceByIdPostTrackInCartsidReplace');
        }
        const baseUrl = `/TrackInCarts/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInCartReplaceByIdPutTrackInCartsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInCartReplaceByIdPutTrackInCartsid');
        }
        const baseUrl = `/TrackInCarts/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options) {
        const baseUrl = `/TrackInCarts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartReplaceOrCreatePutTrackInCarts(params, options) {
        const baseUrl = `/TrackInCarts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInCartUpdateAll(params, options) {
        const baseUrl = `/TrackInCarts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInCartUpsertWithWhere(params, options) {
        const baseUrl = `/TrackInCarts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TrackInCartApi - functional programming interface
 */
exports.TrackInCartApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackInCartCount(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackInCartCreate(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackInCartDeleteById(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInCartExistsGetTrackInCartsidExists(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartExistsGetTrackInCartsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInCartExistsHeadTrackInCartsid(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartExistsHeadTrackInCartsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInCartFind(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackInCartFindById(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInCartFindOne(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartPatchOrCreate(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation cart.
     * @param id TrackInCart id
     * @param refresh
     */
    trackInCartPrototypeGetCart(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartPrototypeGetCart(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackInCart id
     * @param refresh
     */
    trackInCartPrototypeGetTrack(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartPrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackInCart id
     * @param data An object of model property name/value pairs
     */
    trackInCartPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInCartReplaceByIdPostTrackInCartsidReplace(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartReplaceByIdPostTrackInCartsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInCartReplaceByIdPutTrackInCartsid(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartReplaceByIdPutTrackInCartsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartReplaceOrCreatePutTrackInCarts(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartReplaceOrCreatePutTrackInCarts(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInCartUpdateAll(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInCartUpsertWithWhere(params, options) {
        const fetchArgs = exports.TrackInCartApiFetchParamCreator.trackInCartUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TrackInCartApi - object-oriented interface
 */
class TrackInCartApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackInCartCount(params, options) {
        return exports.TrackInCartApiFp.trackInCartCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackInCartCreate(params, options) {
        return exports.TrackInCartApiFp.trackInCartCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options) {
        return exports.TrackInCartApiFp.trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options) {
        return exports.TrackInCartApiFp.trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackInCartDeleteById(params, options) {
        return exports.TrackInCartApiFp.trackInCartDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInCartExistsGetTrackInCartsidExists(params, options) {
        return exports.TrackInCartApiFp.trackInCartExistsGetTrackInCartsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInCartExistsHeadTrackInCartsid(params, options) {
        return exports.TrackInCartApiFp.trackInCartExistsHeadTrackInCartsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInCartFind(params, options) {
        return exports.TrackInCartApiFp.trackInCartFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackInCartFindById(params, options) {
        return exports.TrackInCartApiFp.trackInCartFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInCartFindOne(params, options) {
        return exports.TrackInCartApiFp.trackInCartFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartPatchOrCreate(params, options) {
        return exports.TrackInCartApiFp.trackInCartPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation cart.
     * @param id TrackInCart id
     * @param refresh
     */
    trackInCartPrototypeGetCart(params, options) {
        return exports.TrackInCartApiFp.trackInCartPrototypeGetCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackInCart id
     * @param refresh
     */
    trackInCartPrototypeGetTrack(params, options) {
        return exports.TrackInCartApiFp.trackInCartPrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackInCart id
     * @param data An object of model property name/value pairs
     */
    trackInCartPrototypePatchAttributes(params, options) {
        return exports.TrackInCartApiFp.trackInCartPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInCartReplaceByIdPostTrackInCartsidReplace(params, options) {
        return exports.TrackInCartApiFp.trackInCartReplaceByIdPostTrackInCartsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInCartReplaceByIdPutTrackInCartsid(params, options) {
        return exports.TrackInCartApiFp.trackInCartReplaceByIdPutTrackInCartsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options) {
        return exports.TrackInCartApiFp.trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInCartReplaceOrCreatePutTrackInCarts(params, options) {
        return exports.TrackInCartApiFp.trackInCartReplaceOrCreatePutTrackInCarts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInCartUpdateAll(params, options) {
        return exports.TrackInCartApiFp.trackInCartUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInCartUpsertWithWhere(params, options) {
        return exports.TrackInCartApiFp.trackInCartUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TrackInCartApi = TrackInCartApi;
/**
 * TrackInCartApi - factory interface
 */
const TrackInCartApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        trackInCartCount(params, options) {
            return exports.TrackInCartApiFp.trackInCartCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        trackInCartCreate(params, options) {
            return exports.TrackInCartApiFp.trackInCartCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options) {
            return exports.TrackInCartApiFp.trackInCartCreateChangeStreamGetTrackInCartsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options) {
            return exports.TrackInCartApiFp.trackInCartCreateChangeStreamPostTrackInCartsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        trackInCartDeleteById(params, options) {
            return exports.TrackInCartApiFp.trackInCartDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackInCartExistsGetTrackInCartsidExists(params, options) {
            return exports.TrackInCartApiFp.trackInCartExistsGetTrackInCartsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackInCartExistsHeadTrackInCartsid(params, options) {
            return exports.TrackInCartApiFp.trackInCartExistsHeadTrackInCartsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackInCartFind(params, options) {
            return exports.TrackInCartApiFp.trackInCartFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        trackInCartFindById(params, options) {
            return exports.TrackInCartApiFp.trackInCartFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackInCartFindOne(params, options) {
            return exports.TrackInCartApiFp.trackInCartFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackInCartPatchOrCreate(params, options) {
            return exports.TrackInCartApiFp.trackInCartPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation cart.
         * @param id TrackInCart id
         * @param refresh
         */
        trackInCartPrototypeGetCart(params, options) {
            return exports.TrackInCartApiFp.trackInCartPrototypeGetCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation track.
         * @param id TrackInCart id
         * @param refresh
         */
        trackInCartPrototypeGetTrack(params, options) {
            return exports.TrackInCartApiFp.trackInCartPrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id TrackInCart id
         * @param data An object of model property name/value pairs
         */
        trackInCartPrototypePatchAttributes(params, options) {
            return exports.TrackInCartApiFp.trackInCartPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackInCartReplaceByIdPostTrackInCartsidReplace(params, options) {
            return exports.TrackInCartApiFp.trackInCartReplaceByIdPostTrackInCartsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackInCartReplaceByIdPutTrackInCartsid(params, options) {
            return exports.TrackInCartApiFp.trackInCartReplaceByIdPutTrackInCartsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options) {
            return exports.TrackInCartApiFp.trackInCartReplaceOrCreatePostTrackInCartsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackInCartReplaceOrCreatePutTrackInCarts(params, options) {
            return exports.TrackInCartApiFp.trackInCartReplaceOrCreatePutTrackInCarts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackInCartUpdateAll(params, options) {
            return exports.TrackInCartApiFp.trackInCartUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackInCartUpsertWithWhere(params, options) {
            return exports.TrackInCartApiFp.trackInCartUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TrackInCartApiFactory = TrackInCartApiFactory;
/**
 * TrackInPlaylistApi - fetch parameter creator
 */
exports.TrackInPlaylistApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackInPlaylistCount(params, options) {
        const baseUrl = `/TrackInPlaylists/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackInPlaylistCreate(params, options) {
        const baseUrl = `/TrackInPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options) {
        const baseUrl = `/TrackInPlaylists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options) {
        const baseUrl = `/TrackInPlaylists/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackInPlaylistDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistDeleteById');
        }
        const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistExistsGetTrackInPlaylistsidExists');
        }
        const baseUrl = `/TrackInPlaylists/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInPlaylistExistsHeadTrackInPlaylistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistExistsHeadTrackInPlaylistsid');
        }
        const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInPlaylistFind(params, options) {
        const baseUrl = `/TrackInPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackInPlaylistFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistFindById');
        }
        const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInPlaylistFindOne(params, options) {
        const baseUrl = `/TrackInPlaylists/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistPatchOrCreate(params, options) {
        const baseUrl = `/TrackInPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation playlist.
     * @param id TrackInPlaylist id
     * @param refresh
     */
    trackInPlaylistPrototypeGetPlaylist(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistPrototypeGetPlaylist');
        }
        const baseUrl = `/TrackInPlaylists/{id}/playlist`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackInPlaylist id
     * @param refresh
     */
    trackInPlaylistPrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistPrototypeGetTrack');
        }
        const baseUrl = `/TrackInPlaylists/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackInPlaylist id
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistPrototypePatchAttributes');
        }
        const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace');
        }
        const baseUrl = `/TrackInPlaylists/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackInPlaylistReplaceByIdPutTrackInPlaylistsid');
        }
        const baseUrl = `/TrackInPlaylists/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options) {
        const baseUrl = `/TrackInPlaylists/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options) {
        const baseUrl = `/TrackInPlaylists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistUpdateAll(params, options) {
        const baseUrl = `/TrackInPlaylists/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistUpsertWithWhere(params, options) {
        const baseUrl = `/TrackInPlaylists/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TrackInPlaylistApi - functional programming interface
 */
exports.TrackInPlaylistApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackInPlaylistCount(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackInPlaylistCreate(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackInPlaylistDeleteById(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInPlaylistExistsHeadTrackInPlaylistsid(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistExistsHeadTrackInPlaylistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInPlaylistFind(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackInPlaylistFindById(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInPlaylistFindOne(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistPatchOrCreate(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation playlist.
     * @param id TrackInPlaylist id
     * @param refresh
     */
    trackInPlaylistPrototypeGetPlaylist(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistPrototypeGetPlaylist(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackInPlaylist id
     * @param refresh
     */
    trackInPlaylistPrototypeGetTrack(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistPrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackInPlaylist id
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistUpdateAll(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistUpsertWithWhere(params, options) {
        const fetchArgs = exports.TrackInPlaylistApiFetchParamCreator.trackInPlaylistUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TrackInPlaylistApi - object-oriented interface
 */
class TrackInPlaylistApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackInPlaylistCount(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackInPlaylistCreate(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackInPlaylistDeleteById(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackInPlaylistExistsHeadTrackInPlaylistsid(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistExistsHeadTrackInPlaylistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInPlaylistFind(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackInPlaylistFindById(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackInPlaylistFindOne(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistPatchOrCreate(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation playlist.
     * @param id TrackInPlaylist id
     * @param refresh
     */
    trackInPlaylistPrototypeGetPlaylist(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistPrototypeGetPlaylist(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackInPlaylist id
     * @param refresh
     */
    trackInPlaylistPrototypeGetTrack(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistPrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackInPlaylist id
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistPrototypePatchAttributes(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistUpdateAll(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackInPlaylistUpsertWithWhere(params, options) {
        return exports.TrackInPlaylistApiFp.trackInPlaylistUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TrackInPlaylistApi = TrackInPlaylistApi;
/**
 * TrackInPlaylistApi - factory interface
 */
const TrackInPlaylistApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        trackInPlaylistCount(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        trackInPlaylistCreate(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamGetTrackInPlaylistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistCreateChangeStreamPostTrackInPlaylistsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        trackInPlaylistDeleteById(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistExistsGetTrackInPlaylistsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackInPlaylistExistsHeadTrackInPlaylistsid(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistExistsHeadTrackInPlaylistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackInPlaylistFind(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        trackInPlaylistFindById(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackInPlaylistFindOne(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackInPlaylistPatchOrCreate(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation playlist.
         * @param id TrackInPlaylist id
         * @param refresh
         */
        trackInPlaylistPrototypeGetPlaylist(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistPrototypeGetPlaylist(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation track.
         * @param id TrackInPlaylist id
         * @param refresh
         */
        trackInPlaylistPrototypeGetTrack(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistPrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id TrackInPlaylist id
         * @param data An object of model property name/value pairs
         */
        trackInPlaylistPrototypePatchAttributes(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPostTrackInPlaylistsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceByIdPutTrackInPlaylistsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePostTrackInPlaylistsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistReplaceOrCreatePutTrackInPlaylists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackInPlaylistUpdateAll(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackInPlaylistUpsertWithWhere(params, options) {
            return exports.TrackInPlaylistApiFp.trackInPlaylistUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TrackInPlaylistApiFactory = TrackInPlaylistApiFactory;
/**
 * TrackMoodApi - fetch parameter creator
 */
exports.TrackMoodApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackMoodCount(params, options) {
        const baseUrl = `/TrackMoods/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackMoodCreate(params, options) {
        const baseUrl = `/TrackMoods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options) {
        const baseUrl = `/TrackMoods/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options) {
        const baseUrl = `/TrackMoods/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackMoodDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodDeleteById');
        }
        const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackMoodExistsGetTrackMoodsidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodExistsGetTrackMoodsidExists');
        }
        const baseUrl = `/TrackMoods/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackMoodExistsHeadTrackMoodsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodExistsHeadTrackMoodsid');
        }
        const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackMoodFind(params, options) {
        const baseUrl = `/TrackMoods`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackMoodFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodFindById');
        }
        const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackMoodFindOne(params, options) {
        const baseUrl = `/TrackMoods/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodPatchOrCreate(params, options) {
        const baseUrl = `/TrackMoods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation mood.
     * @param id TrackMood id
     * @param refresh
     */
    trackMoodPrototypeGetMood(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodPrototypeGetMood');
        }
        const baseUrl = `/TrackMoods/{id}/mood`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackMood id
     * @param refresh
     */
    trackMoodPrototypeGetTrack(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodPrototypeGetTrack');
        }
        const baseUrl = `/TrackMoods/{id}/track`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            refresh: params['refresh'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackMood id
     * @param data An object of model property name/value pairs
     */
    trackMoodPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodPrototypePatchAttributes');
        }
        const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackMoodReplaceByIdPostTrackMoodsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodReplaceByIdPostTrackMoodsidReplace');
        }
        const baseUrl = `/TrackMoods/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackMoodReplaceByIdPutTrackMoodsid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling trackMoodReplaceByIdPutTrackMoodsid');
        }
        const baseUrl = `/TrackMoods/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options) {
        const baseUrl = `/TrackMoods/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodReplaceOrCreatePutTrackMoods(params, options) {
        const baseUrl = `/TrackMoods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackMoodUpdateAll(params, options) {
        const baseUrl = `/TrackMoods/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackMoodUpsertWithWhere(params, options) {
        const baseUrl = `/TrackMoods/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TrackMoodApi - functional programming interface
 */
exports.TrackMoodApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackMoodCount(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackMoodCreate(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackMoodDeleteById(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackMoodExistsGetTrackMoodsidExists(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodExistsGetTrackMoodsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackMoodExistsHeadTrackMoodsid(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodExistsHeadTrackMoodsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackMoodFind(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackMoodFindById(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackMoodFindOne(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodPatchOrCreate(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation mood.
     * @param id TrackMood id
     * @param refresh
     */
    trackMoodPrototypeGetMood(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodPrototypeGetMood(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackMood id
     * @param refresh
     */
    trackMoodPrototypeGetTrack(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodPrototypeGetTrack(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackMood id
     * @param data An object of model property name/value pairs
     */
    trackMoodPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackMoodReplaceByIdPostTrackMoodsidReplace(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodReplaceByIdPostTrackMoodsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackMoodReplaceByIdPutTrackMoodsid(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodReplaceByIdPutTrackMoodsid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodReplaceOrCreatePutTrackMoods(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodReplaceOrCreatePutTrackMoods(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackMoodUpdateAll(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackMoodUpsertWithWhere(params, options) {
        const fetchArgs = exports.TrackMoodApiFetchParamCreator.trackMoodUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TrackMoodApi - object-oriented interface
 */
class TrackMoodApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    trackMoodCount(params, options) {
        return exports.TrackMoodApiFp.trackMoodCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    trackMoodCreate(params, options) {
        return exports.TrackMoodApiFp.trackMoodCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options) {
        return exports.TrackMoodApiFp.trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options) {
        return exports.TrackMoodApiFp.trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    trackMoodDeleteById(params, options) {
        return exports.TrackMoodApiFp.trackMoodDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackMoodExistsGetTrackMoodsidExists(params, options) {
        return exports.TrackMoodApiFp.trackMoodExistsGetTrackMoodsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    trackMoodExistsHeadTrackMoodsid(params, options) {
        return exports.TrackMoodApiFp.trackMoodExistsHeadTrackMoodsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackMoodFind(params, options) {
        return exports.TrackMoodApiFp.trackMoodFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    trackMoodFindById(params, options) {
        return exports.TrackMoodApiFp.trackMoodFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    trackMoodFindOne(params, options) {
        return exports.TrackMoodApiFp.trackMoodFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodPatchOrCreate(params, options) {
        return exports.TrackMoodApiFp.trackMoodPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation mood.
     * @param id TrackMood id
     * @param refresh
     */
    trackMoodPrototypeGetMood(params, options) {
        return exports.TrackMoodApiFp.trackMoodPrototypeGetMood(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation track.
     * @param id TrackMood id
     * @param refresh
     */
    trackMoodPrototypeGetTrack(params, options) {
        return exports.TrackMoodApiFp.trackMoodPrototypeGetTrack(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TrackMood id
     * @param data An object of model property name/value pairs
     */
    trackMoodPrototypePatchAttributes(params, options) {
        return exports.TrackMoodApiFp.trackMoodPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackMoodReplaceByIdPostTrackMoodsidReplace(params, options) {
        return exports.TrackMoodApiFp.trackMoodReplaceByIdPostTrackMoodsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    trackMoodReplaceByIdPutTrackMoodsid(params, options) {
        return exports.TrackMoodApiFp.trackMoodReplaceByIdPutTrackMoodsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options) {
        return exports.TrackMoodApiFp.trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    trackMoodReplaceOrCreatePutTrackMoods(params, options) {
        return exports.TrackMoodApiFp.trackMoodReplaceOrCreatePutTrackMoods(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackMoodUpdateAll(params, options) {
        return exports.TrackMoodApiFp.trackMoodUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    trackMoodUpsertWithWhere(params, options) {
        return exports.TrackMoodApiFp.trackMoodUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TrackMoodApi = TrackMoodApi;
/**
 * TrackMoodApi - factory interface
 */
const TrackMoodApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        trackMoodCount(params, options) {
            return exports.TrackMoodApiFp.trackMoodCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        trackMoodCreate(params, options) {
            return exports.TrackMoodApiFp.trackMoodCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options) {
            return exports.TrackMoodApiFp.trackMoodCreateChangeStreamGetTrackMoodsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options) {
            return exports.TrackMoodApiFp.trackMoodCreateChangeStreamPostTrackMoodsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        trackMoodDeleteById(params, options) {
            return exports.TrackMoodApiFp.trackMoodDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackMoodExistsGetTrackMoodsidExists(params, options) {
            return exports.TrackMoodApiFp.trackMoodExistsGetTrackMoodsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        trackMoodExistsHeadTrackMoodsid(params, options) {
            return exports.TrackMoodApiFp.trackMoodExistsHeadTrackMoodsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackMoodFind(params, options) {
            return exports.TrackMoodApiFp.trackMoodFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        trackMoodFindById(params, options) {
            return exports.TrackMoodApiFp.trackMoodFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        trackMoodFindOne(params, options) {
            return exports.TrackMoodApiFp.trackMoodFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackMoodPatchOrCreate(params, options) {
            return exports.TrackMoodApiFp.trackMoodPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation mood.
         * @param id TrackMood id
         * @param refresh
         */
        trackMoodPrototypeGetMood(params, options) {
            return exports.TrackMoodApiFp.trackMoodPrototypeGetMood(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation track.
         * @param id TrackMood id
         * @param refresh
         */
        trackMoodPrototypeGetTrack(params, options) {
            return exports.TrackMoodApiFp.trackMoodPrototypeGetTrack(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id TrackMood id
         * @param data An object of model property name/value pairs
         */
        trackMoodPrototypePatchAttributes(params, options) {
            return exports.TrackMoodApiFp.trackMoodPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackMoodReplaceByIdPostTrackMoodsidReplace(params, options) {
            return exports.TrackMoodApiFp.trackMoodReplaceByIdPostTrackMoodsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        trackMoodReplaceByIdPutTrackMoodsid(params, options) {
            return exports.TrackMoodApiFp.trackMoodReplaceByIdPutTrackMoodsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options) {
            return exports.TrackMoodApiFp.trackMoodReplaceOrCreatePostTrackMoodsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        trackMoodReplaceOrCreatePutTrackMoods(params, options) {
            return exports.TrackMoodApiFp.trackMoodReplaceOrCreatePutTrackMoods(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackMoodUpdateAll(params, options) {
            return exports.TrackMoodApiFp.trackMoodUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        trackMoodUpsertWithWhere(params, options) {
            return exports.TrackMoodApiFp.trackMoodUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TrackMoodApiFactory = TrackMoodApiFactory;
/**
 * UserApi - fetch parameter creator
 */
exports.UserApiFetchParamCreator = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    userChangePassword(params, options) {
        // verify required parameter "oldPassword" is set
        if (params['oldPassword'] == null) {
            throw new Error('Missing required parameter oldPassword when calling userChangePassword');
        }
        // verify required parameter "newPassword" is set
        if (params['newPassword'] == null) {
            throw new Error('Missing required parameter newPassword when calling userChangePassword');
        }
        const baseUrl = `/Users/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            oldPassword: params['oldPassword'],
            newPassword: params['newPassword'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    userConfirm(params, options) {
        // verify required parameter "uid" is set
        if (params['uid'] == null) {
            throw new Error('Missing required parameter uid when calling userConfirm');
        }
        // verify required parameter "token" is set
        if (params['token'] == null) {
            throw new Error('Missing required parameter token when calling userConfirm');
        }
        const baseUrl = `/Users/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            uid: params['uid'],
            token: params['token'],
            redirect: params['redirect'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params, options) {
        const baseUrl = `/Users/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params, options) {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    userCreateChangeStreamGetUsersChangeStream(params, options) {
        const baseUrl = `/Users/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            options: params['options'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    userCreateChangeStreamPostUsersChangeStream(params, options) {
        const baseUrl = `/Users/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            options: params['options'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userDeleteById');
        }
        const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userExistsGetUsersidExists');
        }
        const baseUrl = `/Users/{id}/exists`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userExistsHeadUsersid');
        }
        const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'HEAD' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params, options) {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userFindById');
        }
        const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params, options) {
        const baseUrl = `/Users/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params, options) {
        // verify required parameter "credentials" is set
        if (params['credentials'] == null) {
            throw new Error('Missing required parameter credentials when calling userLogin');
        }
        const baseUrl = `/Users/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            include: params['include'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['credentials']) {
            fetchOptions.body = JSON.stringify(params['credentials'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    userLogout(options) {
        const baseUrl = `/Users/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params, options) {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeCountAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens/count`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data
     */
    userPrototypeCreateAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeCreateAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeDeleteAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeDestroyByIdAccessTokens');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling userPrototypeDestroyByIdAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'DELETE' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeFindByIdAccessTokens');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling userPrototypeFindByIdAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter
     */
    userPrototypeGetAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeGetAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            filter: params['filter'],
        });
        let fetchOptions = assign({}, { method: 'GET' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypePatchAttributes');
        }
        const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PATCH' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    userPrototypeUpdateByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeUpdateByIdAccessTokens');
        }
        // verify required parameter "fk" is set
        if (params['fk'] == null) {
            throw new Error('Missing required parameter fk when calling userPrototypeUpdateByIdAccessTokens');
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${'id'}}`, `${params['id']}`)
            .replace(`{${'fk'}}`, `${params['fk']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userPrototypeVerify');
        }
        const baseUrl = `/Users/{id}/verify`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userReplaceByIdPostUsersidReplace');
        }
        const baseUrl = `/Users/{id}/replace`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params, options) {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling userReplaceByIdPutUsersid');
        }
        const baseUrl = `/Users/{id}`.replace(`{${'id'}}`, `${params['id']}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params, options) {
        const baseUrl = `/Users/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params, options) {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'PUT' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    userResetPassword(params, options) {
        // verify required parameter "options" is set
        if (params['options'] == null) {
            throw new Error('Missing required parameter options when calling userResetPassword');
        }
        const baseUrl = `/Users/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['options']) {
            fetchOptions.body = JSON.stringify(params['options'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    userSetPassword(params, options) {
        // verify required parameter "newPassword" is set
        if (params['newPassword'] == null) {
            throw new Error('Missing required parameter newPassword when calling userSetPassword');
        }
        const baseUrl = `/Users/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            newPassword: params['newPassword'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params, options) {
        const baseUrl = `/Users/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params, options) {
        const baseUrl = `/Users/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            where: params['where'],
        });
        let fetchOptions = assign({}, { method: 'POST' }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['data']) {
            fetchOptions.body = JSON.stringify(params['data'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * UserApi - functional programming interface
 */
exports.UserApiFp = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    userChangePassword(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userChangePassword(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    userConfirm(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userConfirm(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userCount(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    userCreateChangeStreamGetUsersChangeStream(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userCreateChangeStreamGetUsersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    userCreateChangeStreamPostUsersChangeStream(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userCreateChangeStreamPostUsersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userExistsGetUsersidExists(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userExistsHeadUsersid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userFind(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userFindById(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userLogin(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    userLogout(options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userLogout(options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeCountAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data
     */
    userPrototypeCreateAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeCreateAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeDeleteAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeFindByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter
     */
    userPrototypeGetAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeGetAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    userPrototypeUpdateByIdAccessTokens(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userPrototypeVerify(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userReplaceByIdPostUsersidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userReplaceByIdPutUsersid(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userReplaceOrCreatePostUsersReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userReplaceOrCreatePutUsers(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    userResetPassword(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userResetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    userSetPassword(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userSetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params, options) {
        const fetchArgs = exports.UserApiFetchParamCreator.userUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = exports.BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * UserApi - object-oriented interface
 */
class UserApi extends BaseAPI {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    userChangePassword(params, options) {
        return exports.UserApiFp.userChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    userConfirm(params, options) {
        return exports.UserApiFp.userConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params, options) {
        return exports.UserApiFp.userCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params, options) {
        return exports.UserApiFp.userCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    userCreateChangeStreamGetUsersChangeStream(params, options) {
        return exports.UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    userCreateChangeStreamPostUsersChangeStream(params, options) {
        return exports.UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params, options) {
        return exports.UserApiFp.userDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params, options) {
        return exports.UserApiFp.userExistsGetUsersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params, options) {
        return exports.UserApiFp.userExistsHeadUsersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params, options) {
        return exports.UserApiFp.userFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params, options) {
        return exports.UserApiFp.userFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params, options) {
        return exports.UserApiFp.userFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params, options) {
        return exports.UserApiFp.userLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logout a user with access token.
     */
    userLogout(options) {
        return exports.UserApiFp.userLogout(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params, options) {
        return exports.UserApiFp.userPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data
     */
    userPrototypeCreateAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter
     */
    userPrototypeGetAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params, options) {
        return exports.UserApiFp.userPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    userPrototypeUpdateByIdAccessTokens(params, options) {
        return exports.UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params, options) {
        return exports.UserApiFp.userPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params, options) {
        return exports.UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params, options) {
        return exports.UserApiFp.userReplaceByIdPutUsersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params, options) {
        return exports.UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params, options) {
        return exports.UserApiFp.userReplaceOrCreatePutUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    userResetPassword(params, options) {
        return exports.UserApiFp.userResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    userSetPassword(params, options) {
        return exports.UserApiFp.userSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params, options) {
        return exports.UserApiFp.userUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params, options) {
        return exports.UserApiFp.userUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.UserApi = UserApi;
/**
 * UserApi - factory interface
 */
const UserApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Change a user's password.
         * @param oldPassword
         * @param newPassword
         */
        userChangePassword(params, options) {
            return exports.UserApiFp.userChangePassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm a user registration with identity verification token.
         * @param uid
         * @param token
         * @param redirect
         */
        userConfirm(params, options) {
            return exports.UserApiFp.userConfirm(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        userCount(params, options) {
            return exports.UserApiFp.userCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        userCreate(params, options) {
            return exports.UserApiFp.userCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        userCreateChangeStreamGetUsersChangeStream(params, options) {
            return exports.UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        userCreateChangeStreamPostUsersChangeStream(params, options) {
            return exports.UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        userDeleteById(params, options) {
            return exports.UserApiFp.userDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        userExistsGetUsersidExists(params, options) {
            return exports.UserApiFp.userExistsGetUsersidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        userExistsHeadUsersid(params, options) {
            return exports.UserApiFp.userExistsHeadUsersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        userFind(params, options) {
            return exports.UserApiFp.userFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        userFindById(params, options) {
            return exports.UserApiFp.userFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        userFindOne(params, options) {
            return exports.UserApiFp.userFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Login a user with username/email and password.
         * @param credentials
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        userLogin(params, options) {
            return exports.UserApiFp.userLogin(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logout a user with access token.
         */
        userLogout(options) {
            return exports.UserApiFp.userLogout(options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userPatchOrCreate(params, options) {
            return exports.UserApiFp.userPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accessTokens of User.
         * @param id User id
         * @param where Criteria to match model instances
         */
        userPrototypeCountAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accessTokens of this model.
         * @param id User id
         * @param data
         */
        userPrototypeCreateAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accessTokens of this model.
         * @param id User id
         */
        userPrototypeDeleteAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         */
        userPrototypeDestroyByIdAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         */
        userPrototypeFindByIdAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accessTokens of User.
         * @param id User id
         * @param filter
         */
        userPrototypeGetAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id User id
         * @param data An object of model property name/value pairs
         */
        userPrototypePatchAttributes(params, options) {
            return exports.UserApiFp.userPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         * @param data
         */
        userPrototypeUpdateByIdAccessTokens(params, options) {
            return exports.UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id User id
         */
        userPrototypeVerify(params, options) {
            return exports.UserApiFp.userPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        userReplaceByIdPostUsersidReplace(params, options) {
            return exports.UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        userReplaceByIdPutUsersid(params, options) {
            return exports.UserApiFp.userReplaceByIdPutUsersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userReplaceOrCreatePostUsersReplaceOrCreate(params, options) {
            return exports.UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userReplaceOrCreatePutUsers(params, options) {
            return exports.UserApiFp.userReplaceOrCreatePutUsers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password for a user with email.
         * @param options
         */
        userResetPassword(params, options) {
            return exports.UserApiFp.userResetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset user's password via a password-reset token.
         * @param newPassword
         */
        userSetPassword(params, options) {
            return exports.UserApiFp.userSetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        userUpdateAll(params, options) {
            return exports.UserApiFp.userUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        userUpsertWithWhere(params, options) {
            return exports.UserApiFp.userUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.UserApiFactory = UserApiFactory;
//# sourceMappingURL=api.js.map